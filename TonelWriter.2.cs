'From Squeak6.0alpha of 11 October 2020 [latest update: #19958] on 12 October 2020 at 8:52:32 am'!Dictionary subclass: #OrderedDictionary	instanceVariableNames: 'order '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!OrderedDictionary commentStamp: 'mt 1/16/2015 10:42' prior: 0!I am an ordered dictionary. I have an additional index (called 'order') to keep track of the insertion order of my associations.The read access is not affected by the additional index.The index is updated in O(1) [time] when inserting new keys. For present keys, that insertion involves actions in O(n) to move the respective element to the end of the order.The growth operation compacts the index and takes O(n) additional time.NOTE: This is still no instance of SequenceableCollection. Having this, some protocols are missing and may require working on #associations, which is an Array and thus sequenceable.!Object subclass: #Protocol	instanceVariableNames: 'methods name'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Protocols'!!Protocol commentStamp: '<historical>' prior: 0!A Protocol is a simple value holder representing a protocol.It's composed of a name and a set of method selectors!Object subclass: #STON	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STON commentStamp: 'SvenVanCaekenberghe 3/15/2016 14:23' prior: 0!STON implements serialization and materialization using the Smalltalk Object Notation format.I am a class side facade offering a high level API to write and read objects using STON.U s a g eBasic operations  #toString:  #fromString:  STON toString: DisplayScreen boundingBox.  STON fromString:  'Rectangle{#origin:Point[0,0],#corner:Point[1920,1030]}'.  STON toString: { DateAndTime now. Float pi. 1 to: 10 by: 2. 3 days }.  STON fromString:  '[DateAndTime[''2016-03-15T13:57:59.462422+01:00''],3.141592653589793,Interval{#start:1,#stop:10,#step:2},Duration{#nanos:0,#seconds:259200}]'You can also read from or write to streams  #fromStream:  #put:onStream:There is also the option to do pretty printing (indenting, multi line output)   #toStringPretty:  #put:onStreamPretty:STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using #fromString: or #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using:   #toJsonString[Pretty]:  #put:asJsonOnStream[Pretty]:Note that you can only write Arrays and Dictionaries !!For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.Like JSON, STON does not allow for comments. However, a preprocessor option can skip C style comments before parsing.I also define some contants used in the implementation: the class used as list, map and association, as well as the optional class name key (used when reading objects using an unknown class).I m p l e m e n t a t i o nThe 2 key methods are  #stonOn:  #fromSton:which work together with STONWriter and STONReader; read their class comments for all configuration options (you can use the #reader and #writer methods to avoid referring to these classes directly).Several methods are used to support and/or control the implementation  #stonName - defines the external name for a class  #stonAllInstVarNames - defines which instance variable to write  #stonContainSubObjects - shortcut looking into objects for subobjects  #stonShouldWriteNilInstVars - option to skip writing nil valued instance variablesS y n t a x	value	  primitive-value	  object-value	  reference	  nil	primitive-value	  number	  true	  false	  symbol	  string	object-value	  object	  map	  list	object	  classname map	  classname list	reference	  @ int-index-previous-object-value	map	  {}	  { members }	members	  pair	  pair , members	pair	  string : value	  symbol : value	  number : value	list	  []	  [ elements ]	elements	  value 	  value , elements	string	  ''	  ' chars '	chars	  char	  char chars	char	  any-printable-ASCII-character-	    except-'-"-or-\	  \'	  \"	  \\	  \/	  \b	  \f	  \n	  \r	  \t	  \u four-hex-digits	symbol	  # chars-limited	  # ' chars '	chars-limited	  char-limited	  char-limited chars-limited	char-limited	  a-z A-Z 0-9 - _ . /	classname	  uppercase-alpha-char alphanumeric-char	number	  int	  int frac	  int exp	  int frac exp	int	  digit	  digit1-9 digits 	  - digit	  - digit1-9 digits	frac	  . digits	exp	  e digits	digits	  digit	  digit digits	e	  e	  e+	  e-	  E	  E+	  E-!Object subclass: #STONCStyleCommentsSkipStream	instanceVariableNames: 'stream peekedCharacter delimiter escape'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONCStyleCommentsSkipStream commentStamp: 'SvenVanCaekenberghe 7/17/2015 13:50' prior: 0!I am STONCStyleCommentsSkipStream, a character ReadStream wrapping another character ReadStream. I skip C style comments, much like a classic C preprocessor.C, C++, Java, JavaScript style comments are either the multiline	/* a comment */	or the single line, up to end of line	// a comment 	I deal with any end of line convention. Multiline comments cannot be nested. You create me #on: another character ReadStream. Here is an example:	(STONCStyleCommentsSkipStream on: 'abc/*comment*/def' readStream) upToEnd.	Comments inside single and double quote delimited strings are ignored. Backslash escapes for single and double quotes inside strings are honored.!Object subclass: #STONJSON	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONJSON commentStamp: 'SvenVanCaekenberghe 3/15/2016 15:16' prior: 0!I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using  #fromString:  #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using  #toString[Pretty]:  #put:onStream[Pretty]:Note that you can only write Arrays and Dictionaries !! Shared and circular references will be noted and signalled using an exception.E x a m p l e s  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.  STONJSON fromString: '[1,-1,3.141592653589793,true,"JSON"]'.  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.  STONJSON fromString: '{"foo":1,"bar":2,"sub":{"a":true,"b":false},"flags":[1,8,32]}'. For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.!Object subclass: #STONReader	instanceVariableNames: 'readStream objects classes unresolvedReferences stringStream acceptUnknownClasses newLine convertNewLines'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONReader commentStamp: 'SvenVanCaekenberghe 10/24/2016 10:29' prior: 0!STONReader materializes objects using the Smalltalk Object Notation format.This parser is backwards compatible with standard JSON.Customization options are:- acceptUnknownClasses <Boolean> default is false	if true, unknown class names are allowed, the standard #mapClass (Dictionary) is instanciated and the class name is added under #classNameKey (#className)	if false, unknown class names result in a NotFound error- convertNewLines <Boolean> default is false	if true, any unescaped EOL sequence CR, LF or CRLF inside strings or symbols is read and converted as the chosen EOL sequence	if false, CR, LF and CRLF are read unmodified- newLine <String> default is String cr	sequence to use as EOL!Error subclass: #STONReaderError	instanceVariableNames: 'streamPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONReaderError commentStamp: '<historical>' prior: 0!STONReaderError is the error/exception signalled by STONReader when illegal/incorrect input is seen. !Object subclass: #STONReference	instanceVariableNames: 'index'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONReference commentStamp: 'SvenVanCaekenberghe 1/22/2012 20:13' prior: 0!STONReference holds a forward reference to another object during materialization.!Object subclass: #STONStreamWriter	instanceVariableNames: 'writer first'	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONStreamWriter commentStamp: '<historical>' prior: 0!STONStreamWriter helps in streaming writing STON representations.This is an abstract class.!STONStreamWriter subclass: #STONListWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONListWriter commentStamp: '<historical>' prior: 0!STONArrayWriter helps in writing array based STON representations.!STONStreamWriter subclass: #STONMapWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONMapWriter commentStamp: '<historical>' prior: 0!STONDictionaryWriter helps in writing dictionary based STON representations.!STONListWriter subclass: #STONShortListWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONShortListWriter commentStamp: '<historical>' prior: 0!STONShortArrayWriter helps in writing short array based STON representations.!Object subclass: #STONWriter	instanceVariableNames: 'writeStream prettyPrint newLine asciiOnly jsonMode keepNewLines referencePolicy level objects'	classVariableNames: 'STONCharacters STONSimpleSymbolCharacters'	poolDictionaries: ''	category: 'STON-Core'!!STONWriter commentStamp: 'SvenVanCaekenberghe 7/2/2015 15:28' prior: 0!STONWriter serializes objects using the Smalltalk Object Notation format. Customization options are:- prettyPrint <Boolean> default is false	if true, produce pretty printed output- newLine <String> default is String cr	what sequence to use for EOL- asciiOnly <Boolean> default is false   if true, use \u escapes for all non-ASCII characters   most common control characters are still escaped- jsonMode <Boolean> default is false	if true, the follow changes occur	- strings are delimited with double quotes	- nil is encoded as null	- symbols are treated as strings	- only STON listClass and STON mapClass instances are allowed as composite objects	it is wise to also use either #error or #ignore as referencePolicy to avoid references- referencePolicy <#normal|#ignore|#error> default is #normal	if #normal, track and count object references and use references to implement sharing and break cycles	if #error, track object references and signal STONWriterError when a shared reference is encountered	if #ignore, don't track object references which might loop forever on cycles - keepNewLines <Boolean> default is false	if true, any newline sequence CR, LF or CRLF inside strings or symbols will not be escaped 	but will be written as the newline EOF convention!Error subclass: #STONWriterError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'STON-Core'!!STONWriterError commentStamp: 'SvenVanCaekenberghe 4/26/2012 17:17' prior: 0!STONWriterError is the error/exception signalled by STONWriter when illegal/incorrect input is seen. !Object subclass: #TonelFileUtils	instanceVariableNames: ''	classVariableNames: 'Current'	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelFileUtils commentStamp: 'EstebanLorenzano 9/21/2017 19:03' prior: 0!I declare file operations to be used in tonel. I'm necesary because tonel is meant to be portable, and different dialects have different ways of dealing with file systems. !Error subclass: #TonelParseError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelParseError commentStamp: 'EstebanLorenzano 9/11/2017 11:53' prior: 0!I'm a parsing error. I happen whenever the parsing of a tonel file is broken in someway.!Object subclass: #TonelParser	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelParser commentStamp: 'EstebanLorenzano 9/11/2017 12:09' prior: 0!I'm a parser for tonel files. I parse a class with the following format: Tonel spec====    [comment]    type { typeDefinition }    (        [{ methodMetadata }]        method [            methodBody ]     )*comment---"comment string"is optional (but it should be there, in good design ;)type---Class|Trait|ExtensiontypeDefinition---a STON file with class/trait/extension metadatamethodMetadata---a STON file with method metadatais optional (but also, recommended)method---method declaration as this: Class[ class] >> selectormethodBody ---the method body (we do not parse contents, that's class builder task)!MCVersionReader subclass: #TonelReader	instanceVariableNames: 'packageDirectory'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelReader commentStamp: 'GuillermoPolito 7/11/2018 11:02' prior: 0!I'm a monticello reader for tonel format repositories. I read - a package per directory - a class per file - a set of extensions to a single class per file (for example, all extensions of a package to String will be in a single file)I'm created on a file reference to a directory where the package will be read and the name of the package to read.[[[TonelReader on: 'someDirectoryWithTonelPackages' asFileReference filename: 'MyPackageName']]]My main method is- ==#definitions== reads and parses the tonel file, returns a list of monticello definitions.- ==#snapshot== returns a monticello snapshot with the read definitions.- ==#version== returns a monticello version with the read snapshot.!! Implementation detailsThe monticello versions I return do have artificial information. Since I'm just meant to read versions from a directory, this directory has no information such as commit message, commit time, author, or ancestors. Check the method ==#loadVersionInfo== for more information.!MCDirectoryRepository subclass: #TonelRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelRepository commentStamp: 'EstebanLorenzano 9/11/2017 16:49' prior: 0!I'm a tonel monticello repository!STONWriter subclass: #TonelSTONWriter	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelSTONWriter commentStamp: 'EstebanLorenzano 9/11/2017 11:59' prior: 0!I'm a modified STON writer to make tonel metadata look as we want.- it accept aliasses for classes, so I can say OrderedDictionary -> nil (then I do not have an extra information I do not want). Btw, tonel needs to use ordered dictionaries instead plain dictionaries because output needs to be deterministic, and we want to control the order of attributes we publish.- if dictionary has just one element, it prints it in just one line, to have a more compact view.!Object subclass: #TonelScanner	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelScanner commentStamp: '<historical>' prior: 0!I'm a generic scanner to help on parsing tonel files.!TonelScanner subclass: #TonelCommentScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelCommentScanner commentStamp: '<historical>' prior: 0!I scan comments.!Notification subclass: #TonelShouldIgnore	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelShouldIgnore commentStamp: 'nice 11/12/2018 22:59' prior: 0!I'm a notification to say tonel writer that he should ignore a section. This typically happens on a MCClassTraitDefinition, because it will be managed on MCTraitDefinition.(see TonelWriter>>typeOf:)!TonelScanner subclass: #TonelSourceScanner	instanceVariableNames: 'char prevChar result count isFinished'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelSourceScanner commentStamp: 'nice 11/12/2018 23:01' prior: 0!I'm a scanner to get correct sources from method definitions in Tonel format.Implementation details:Method body is delineated by square brackets in Tonel format, thus I just have to detect enclosing square brackets [].Since a method body can include nested blocks and ByteArray literals, I have to maintain a count of opened and closed brackets in order to correctly detect the end of method body.But method body can also contain isolated brackets (which are not necessarily paired) in following patterns:		- comments like "["		- strings like ']'		- array literals like #( [ )		- literal characters like $] Therefore, I need to be aware of syntax for the four cases above, in order to correctly skip those potentially isolated brackets.!FileUrl subclass: #TonelUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!Error subclass: #TonelWriteError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelWriteError commentStamp: 'PeterUhnak 10/7/2018 16:50' prior: 0!I'm a writing error.I happen whenever an unrecoverable problem was encountered during writing of tonel.!MCWriter subclass: #TonelWriter	instanceVariableNames: 'snapshot packageDir directoryReference'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloTonel-Core'!!TonelWriter commentStamp: 'CyrilFerlicot 10/23/2018 15:52' prior: 0!I'm a monticello writer for tonel format, writing - a package per directory - a class per file - a set of extensions to a single class per file (for example, all extensions of a package to String will be in a single file)I'm created on a file reference to a directory where the package will be written.[[[TonelWriter on: ('someDirectory' asFileReference ensureCreateDirectory)]]]My main methods are- ==#writeVersion:== that receives as argument a monticello version to write, from where I'll extract the corresponding monticello snapshot.- ==#writeSnapshot:== that receives as argument a monticello snapshot to write, from where I'll write all the contained definitions.I also provide a way to easily export a single class in the Tonel format to a stream. [[[	TonelWriter sourceCodeOf: self.		(FileSystem memory / 'test.st') writeStreamDo: [ :s | TonelWriter exportClass: self on: s ]; yourself.]]]!! Implementation detailsNotice that while writing, if the written package/snapshot already exists in the directory I'll overwrite it (i.e., remove it and recreate it).!!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 5/28/2015 15:32'!fromSton: stonReader	"Decode non-variable classes from a map of their instance variables and values.	Override to customize and add a matching #toSton: (see implementors)."		self class isVariable 		ifTrue: [			stonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ]		ifFalse: [			stonReader parseNamedInstVarsFor: self ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/18/2012 20:16'!isStonReference	^ false! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:24'!stonContainSubObjects	"Return true if I contain subObjects that should be processed, false otherwise.	Overwrite when necessary. See also #stonProcessSubObjects:"		^ true! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 5/28/2015 15:06'!stonOn: stonWriter	"Encode non-variable classes with a map of their instance variable and values.	Override to customize and add a matching #fromSton: (see implementors)."	self class isVariable 		ifTrue: [			stonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ]		ifFalse: [			stonWriter writeObject: self ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/14/2016 13:45'!stonPostReferenceResolution	"Hook that is called when references were resolved processing this object or one of its sub objects. This will most probably influence hash values. Override to take appropriate action."! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:22'!stonProcessSubObjects: block	"Execute block to (potentially) change each of my subObjects.	In general, all instance and indexable variables are processed.	Overwrite when necessary. Not used when #stonContainSubObjects returns false."		1 to: self class instSize do: [ :each |		self instVarAt: each put: (block value: (self instVarAt: each)) ].	(self class isVariable and: [ self class isBytes not ])		ifTrue: [			1 to: self basicSize do: [ :each |				self basicAt: each put: (block value: (self basicAt: each)) ] ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/13/2013 23:43'!stonShouldWriteNilInstVars	"Return true if my instance variables that are nil should be written out, 	false otherwise. Overwrite when necessary. By default, return false."		^ false! !!Object methodsFor: 'sources managment' stamp: 'edc 2/12/2008 07:43'!createDirIfnotExists: aDirName(FileDirectory default directoryExists:aDirName)		ifFalse: [FileDirectory default createDirectory: aDirName].	^FileDirectory default directoryNamed: aDirName! !!Object methodsFor: 'sources managment' stamp: 'edc 10/11/2020 08:05'!createSources" Object new createSources"| nameToUse zipped dir |ProtoObject allSubclassesWithLevelDo:[:cl :l| 	dir := self createDirIfnotExists:cl category asString.			Cursor write showWhile: [nameToUse :=  cl printString, FileDirectory dot,'.st'  .		(dir fileExists: nameToUse) ifFalse:[					zipped := dir newFileNamed: nameToUse.	zipped  nextPutAll:  (TonelWriter sourceCodeOf:   cl ) .			zipped close.			].]] startingLevel: 0! !!Association methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 8/15/2015 17:12'!stonOn: stonWriter	self class == STON associationClass		ifTrue: [ stonWriter writeAssociation: self ]		ifFalse: [ super stonOn: stonWriter ]	! !!Boolean methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:24'!stonContainSubObjects 	^ false! !!Boolean methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 15:53'!stonOn: stonWriter	stonWriter writeBoolean: self! !!Character methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 20:02'!stonOn: stonWriter	stonWriter writeObject: self listSingleton: self asString! !!Collection methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!stonOn: stonWriter	stonWriter writeObject: self do: [		stonWriter encodeList: self ]! !!Date methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:26'!stonContainSubObjects 	^ false! !!Date methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/19/2016 22:54'!stonOn: stonWriter	"Use an ISO style YYYY-MM-DD representation"		stonWriter writeObject: self listSingleton: self yyyymmdd! !!DateAndTime methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:25'!stonContainSubObjects 	^ false! !!DateAndTime methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/19/2016 22:57'!stonOn: stonWriter	"Use an ISO representation with all details YYYY-MM-DDTHH:MM:SS.N+TZ (with optional nanoseconds and timezone offset)"		stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream |			self printOn: stream withLeadingSpace: false ])! !!Dictionary methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 14:58'!stonOn: stonWriter	"Instances of STON mapClass will be encoded directly, without a class tag.	Other (sub)classes will be encoded with a class tag and will use a map representation. "		self class == STON mapClass		ifTrue: [ 			stonWriter writeMap: self ]		ifFalse: [ 			stonWriter 				writeObject: self 				do: [ stonWriter encodeMap: self ] ]! !!Dictionary methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/14/2016 13:55'!stonPostReferenceResolution	"When references were resolved in me, the hash of my keys might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !!Number methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:26'!stonContainSubObjects 	^ false! !!Number methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 17:26'!stonOn: stonWriter	stonWriter writeFloat: self asFloat! !!Integer methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 15:47'!stonOn: stonWriter	stonWriter writeInteger: self! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 19:58'!fromSton: stonReader	"Create a new instance and delegate decoding to instance side.	Override only when new instance should be created directly (see implementors). "		^ self new		fromSton: stonReader;		yourself! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/27/2014 11:08'!stonAllInstVarNames	"Override to encode my instances using a custom set of instance variables or to define their order."		^ self allInstVarNames ! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 8/12/2014 13:28'!stonName	"Override to encode my instances using a different class name."		^ self name! !!Character class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 15:17'!fromSton: stonReader	^ stonReader parseListSingleton first! !!Class class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 12/24/2015 20:58'!fromSton: stonReader	| theClassName theClass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	^ theClass! !!Collection class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 13:54'!fromSton: stonReader	| collection |	collection := self new.	stonReader parseListDo: [ :each |		collection add: each ].	^ collection! !!Date class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 15:17'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !!DateAndTime class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 5/28/2015 14:14'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !!HashedCollection class methodsFor: 'private' stamp: 'cmm 11/29/2011 21:23'!arrayType	^ Array! !!Dictionary class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 14:59'!fromSton: stonReader	"Instances of STON mapClass will be read directly and won't arrive here.	Other (sub)classes will use this method."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !!Metaclass class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 12/24/2015 20:59'!fromSton: stonReader	| theClassName theClass theMetaclass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	theMetaclass := theClass class.	^ theMetaclass! !!OrderedDictionary methodsFor: 'enumerating' stamp: 'ul 1/19/2015 19:54'!associationsDo: aBlock	"Iterate over the order instead of the internal array."	order from: 1 to: tally do: aBlock! !!OrderedDictionary methodsFor: 'accessing' stamp: 'ul 1/19/2015 20:06'!atIndex: integer	integer > tally ifTrue: [ self error: 'indices are out of bounds' ].	^order at: integer! !!OrderedDictionary methodsFor: 'accessing' stamp: 'ul 1/19/2015 20:05'!atIndex: integer ifAbsent: exceptionBlock	"As we are sequenceable, provide index-based access."	integer > tally ifTrue: [ ^exceptionBlock value ].	^order at: integer ifAbsent: exceptionBlock! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:31'!eighth	"Answer the eighth element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 8! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:33'!fifth	"Answer the fifth element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 5! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:34'!first	"Answer the first element of the receiver"	^ self atIndex: 1! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/19/2015 10:09'!first: n	"Answer the first n elements of the receiver.	Raise an error if there are not enough elements."	^ self copyFrom: 1 to: n! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:33'!fourth	"Answer the fourth element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 4! !!OrderedDictionary methodsFor: 'accessing' stamp: 'topa 3/30/2017 15:07'!last	"Answer the last element of the receiver"	^ self atIndex: self size! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/19/2015 10:10'!last: n	"Answer the last n elements of the receiver.  	Raise an error if there are not enough elements."	| size |	size := self size.	^ self copyFrom: size - n + 1 to: size! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:31'!ninth	"Answer the ninth element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 9! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:34'!second	"Answer the second element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 2! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:33'!seventh	"Answer the seventh element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 7! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:33'!sixth	"Answer the sixth element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 6! !!OrderedDictionary methodsFor: 'accessing' stamp: 'mt 1/16/2015 10:33'!third	"Answer the third element of the receiver.	Raise an error if there are not enough elements."	^ self atIndex: 3! !!OrderedDictionary methodsFor: 'private' stamp: 'ul 1/19/2015 19:53'!atNewIndex: index put: anObject	super atNewIndex: index put: anObject.	order at: tally put: anObject	! !!OrderedDictionary methodsFor: 'private' stamp: 'ul 1/19/2015 19:53'!growTo: anInteger	| oldOrder |	super growTo: anInteger.	oldOrder := order.	"Grow only to 75%. See #atNewIndex:put: in HashedCollection."	order := self class arrayType new: anInteger + 1 * 3 // 4.	order		replaceFrom: 1		to: tally		with: oldOrder		startingAt: 1! !!OrderedDictionary methodsFor: 'private' stamp: 'ul 1/19/2015 19:53'!initialize: n	super initialize: n.	order := self class arrayType new: n + 1 * 3 // 4! !!OrderedDictionary methodsFor: 'private' stamp: 'ul 1/19/2015 19:53'!scanOrderFor: anObject	1 to: tally do: [ :index |		(order at: index) key = anObject ifTrue: [ ^index ] ].	^nil! !!OrderedDictionary methodsFor: 'copying' stamp: 'mt 1/20/2015 08:08'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	^ self shallowCopy postCopyFrom: startIndex to: endIndex! !!OrderedDictionary methodsFor: 'copying' stamp: 'ul 1/19/2015 20:08'!postCopy	"We must not copy associations again but retrieve them from the array, which is already a copy. See super."	super postCopy.	order := order copy.	1 to: tally do: [ :index |		order at: index put: (array at: (self scanFor: (order at: index) key)) ]! !!OrderedDictionary methodsFor: 'copying' stamp: 'ct 9/27/2019 15:23'!postCopyFrom: startIndex to: endIndex	"Adapted from SequenceableCollection and OrderedCollection."	| oldOrder |		oldOrder := order.	array := self class arrayType		new: (self class goodPrimeAtLeast: endIndex - startIndex + 1 * 4 // 3). "fill 75% to 100%"	order := self class arrayType		new: array size + 1 * 3 // 4. "remove 25%"	startIndex to: endIndex do: [:index | | element |		element := (oldOrder at: index) copy.		order at: index - startIndex + 1 put: element.		array at: (self scanFor: element key) put: element].	tally := endIndex - startIndex + 1.! !!OrderedDictionary methodsFor: 'sorting' stamp: 'ul 1/19/2015 19:51'!isSorted	"Return true if the receiver is sorted by #<=."		^ order		isSortedBetween: 1		and: tally! !!OrderedDictionary methodsFor: 'sorting' stamp: 'ul 1/19/2015 20:02'!sort	self sort: nil! !!OrderedDictionary methodsFor: 'sorting' stamp: 'ul 1/19/2015 19:54'!sort: aSortBlock	"Like in OrderedCollection, sort the associations according to the sort block."	tally <= 1 ifTrue: [ ^self ].	order		mergeSortFrom: 1		to: tally		by: aSortBlock! !!OrderedDictionary methodsFor: 'sorting' stamp: 'mt 1/16/2015 10:19'!sorted: aSortBlockOrNil	^ self copy sort: aSortBlockOrNil! !!OrderedDictionary methodsFor: 'removing' stamp: 'ul 1/19/2015 19:53'!removeKey: key ifAbsent: aBlock	| result |	result := super removeKey: key ifAbsent: [ ^aBlock value ].	(self scanOrderFor: key) ifNotNil: [ :index |		order 			replaceFrom: index			to: tally			with: order			startingAt: index + 1 ]..	order at: tally + 1 put: nil.	^result! !!OrderedDictionary methodsFor: '*Morphic-Explorer' stamp: 'mt 8/10/2016 17:53'!explorerContents	^self keys replace: [ :key |		ObjectExplorerWrapper			with: (self at: key)			name: (key printString contractTo: 32)			model: self ]! !!OrderedDictionary methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/10/2015 15:28'!stonOn: stonWriter	"I store my instances as maps"		stonWriter 		writeObject: self 		do: [ stonWriter encodeMap: self ]! !!OrderedDictionary class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/10/2015 15:29'!fromSton: stonReader	"My instances are stored as maps."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !!Point methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 14:30'!fromSton: stonReader	stonReader parseListDo: [ :each :index |		index = 1 ifTrue: [ x := each ].		index = 2 ifTrue: [ y := each ] ]! !!Point methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/24/2012 10:02'!stonOn: stonWriter	stonWriter writeObject: self streamShortList: [ :array |		array add: x; add: y ]! !!Protocol methodsFor: 'accessing' stamp: 'SebastianTleye 8/28/2013 17:22'!addAllMethodsFrom: aProtocol	aProtocol methods do: [ :each | self addMethod: each ].! !!Protocol methodsFor: 'accessing' stamp: 'EstebanLorenzano 1/16/2014 11:23'!addMethod: aSymbol	^ methods add: aSymbol! !!Protocol methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:21'!methods	^ methods! !!Protocol methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:02'!methods: anObject		methods := anObject! !!Protocol methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:21'!name	^ name! !!Protocol methodsFor: 'accessing' stamp: 'EstebanLorenzano 11/29/2013 15:57'!name: anObject	name := anObject asSymbol! !!Protocol methodsFor: 'accessing' stamp: 'SebastianTleye 8/28/2013 17:03'!removeAllMethods	^ methods removeAll.! !!Protocol methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:11'!removeMethod: aSymbol	^ methods remove: aSymbol! !!Protocol methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:12'!rename: newName	self name: newName! !!Protocol methodsFor: 'initialization' stamp: 'CamilloBruni 7/17/2013 23:07'!initialize	super initialize.	methods := IdentitySet new..	name := self class defaultName.! !!Protocol methodsFor: 'private' stamp: 'EstebanLorenzano 6/17/2013 12:51'!canBeRemoved	^ self isEmpty ! !!Protocol methodsFor: 'printing' stamp: 'BenjaminVanRyseghem 4/12/2012 14:28'!printOn: aStream	aStream 		nextPutAll: (self class name);		nextPutAll: ' (';		nextPutAll: (self name);		nextPutAll: ') - ';		nextPutAll: (self methods size asString);		nextPutAll: ' selector(s)'.! !!Protocol methodsFor: 'testing' stamp: 'EstebanLorenzano 11/29/2013 16:04'!canBeRenamed	^ true! !!Protocol methodsFor: 'testing' stamp: 'EstebanLorenzano 6/28/2013 16:04'!includesSelector: selector	^ methods includes: selector! !!Protocol methodsFor: 'testing' stamp: 'BenjaminVanRyseghem 4/12/2012 16:27'!isEmpty	^ self methods isEmpty! !!Protocol methodsFor: 'testing' stamp: 'EstebanLorenzano 10/2/2013 16:23'!isExtensionProtocol 	^ self name first = $*.! !!Protocol methodsFor: 'testing' stamp: 'EstebanLorenzano 6/27/2013 15:53'!isVirtualProtocol	"A virtual protocol is a calculated one (it does not have any methods by it self)"	^ false! !!Protocol class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 5/28/2013 13:21'!ambiguous	^ #ambiguous! !!Protocol class methodsFor: 'instance creation' stamp: 'MarcusDenker 10/3/2013 17:49'!empty 	 ^ self name: #''! !!Protocol class methodsFor: 'instance creation' stamp: 'BenjaminVanRyseghem 4/12/2012 14:06'!name: nm	^ self new		name: nm;		yourself! !!Protocol class methodsFor: 'instance creation' stamp: 'BenjaminVanRyseghem 4/12/2012 14:02'!name: nm methods: methods 	^ self new		methods: methods;		name: nm;		yourself! !!Protocol class methodsFor: 'accessing' stamp: 'EstebanLorenzano 5/28/2013 14:16'!defaultName	^  self unclassified! !!Protocol class methodsFor: 'accessing' stamp: 'MarcusDenker 10/3/2013 17:49'!nullCategory	^ #'no messages'! !!Protocol class methodsFor: 'accessing' stamp: 'EstebanLorenzano 5/28/2013 14:15'!unclassified	^ #'as yet unclassified'! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 8/15/2015 17:11'!associationClass	^ Association! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 8/12/2014 15:04'!classNameKey	^ #className! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/15/2016 14:40'!jsonWriter	^ STONWriter new			jsonMode: true;			referencePolicy: #error;			yourself! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 09:36'!listClass	^ Array! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 09:36'!mapClass	^ Dictionary! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 09:37'!reader	^ STONReader new! !!STON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 09:37'!writer	^ STONWriter new! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/24/2012 09:39'!fromStream: readStream	^ (self reader on: readStream) next! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 6/9/2015 10:03'!fromStreamWithComments: readStream	^ (self reader on: (STONCStyleCommentsSkipStream on: readStream)) next! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/24/2012 09:40'!fromString: string	^ self fromStream: string readStream! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 6/9/2015 10:03'!fromStringWithComments: string	^ self fromStreamWithComments: string readStream! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 5/30/2012 22:06'!put: object asJsonOnStream: stream	(self jsonWriter on: stream) nextPut: object! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 5/30/2012 22:07'!put: object asJsonOnStreamPretty: stream	(self jsonWriter on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/24/2012 09:49'!put: object onStream: stream	(self writer on: stream) nextPut: object! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 2/12/2012 19:30'!put: object onStreamPretty: stream	(self writer on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 5/30/2012 22:07'!toJsonString: object	^ String streamContents: [ :stream |		self put: object asJsonOnStream: stream ]! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 5/30/2012 22:07'!toJsonStringPretty: object	^ String streamContents: [ :stream |		self put: object asJsonOnStreamPretty: stream ]! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/24/2012 09:49'!toString: object	^ String streamContents: [ :stream |		self put: object onStream: stream ]! !!STON class methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 2/12/2012 19:30'!toStringPretty: object	^ String streamContents: [ :stream |		self put: object onStreamPretty: stream ]! !!STONCStyleCommentsSkipStream methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2015 23:24'!atEnd	^ self peek isNil! !!STONCStyleCommentsSkipStream methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:58'!isBinary	^ false! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/8/2015 22:58'!close	stream close! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/8/2015 22:58'!on: readStream	stream := readStream! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:55'!collectionSpecies	^ String! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 23:06'!next	^ peekedCharacter		ifNil: [ 			stream atEnd				ifFalse: [ self nextNonCommentChar ] ]		ifNotNil: [ | character |			character := peekedCharacter.			peekedCharacter := nil.			character ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!next: requestedCount 	"Read requestedCount elements into new collection and return it,	 it could be that less elements were available"	^ self 		next: requestedCount 		into: (self collectionSpecies new: requestedCount)! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!next: requestedCount into: collection	"Read requestedCount elements into collection,	returning a copy if less elements are available"		^ self		next: requestedCount		into: collection		startingAt: 1! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!next: requestedCount into: collection startingAt: offset	"Read requestedCount elements into collection starting at offset,	returning a copy if less elements are available"		| readCount |	readCount := self 		readInto: collection 		startingAt: offset 		count: requestedCount.	^ requestedCount = readCount		ifTrue: [ collection ]		ifFalse: [ collection copyFrom: 1 to: offset + readCount - 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!nextLine	"Read a CR, LF or CRLF terminated line, returning the contents of the line without the EOL. Return nil when the receiver is #atEnd."		self atEnd ifTrue: [ ^ nil ].	^ self collectionSpecies streamContents: [ :out | | eol char |		eol := false.		[ eol ] whileFalse: [ 			char := self next.			(char isNil or: [ char = Character lf ])				ifTrue: [ eol := true ]				ifFalse: [ 					char = Character cr 						ifTrue: [ eol := true. self peekFor: Character lf ]						ifFalse: [  out nextPut: char ] ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 23:06'!peek	^ peekedCharacter		ifNil: [			stream atEnd				ifFalse: [ 					peekedCharacter := self nextNonCommentChar ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!peekFor: object	^ self peek = object		ifTrue: [ 			self next.			true ]		ifFalse: [ false ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2015 10:01'!position	^ stream position! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!readInto: collection startingAt: offset count: requestedCount 	"Read count elements and place them in collection starting at offset.	Return the number of elements actually read."		^ peekedCharacter 		ifNil: [ | readCount |			[ readCount := self encoder 					readInto: collection 					startingAt: offset 					count: requestedCount 					fromStream: stream ]				on: ZnByteStringBecameWideString 				do: [ :byteStringBecameWideString | 					byteStringBecameWideString becomeForward; resume ].			readCount ]		ifNotNil: [ 			collection at: offset put: peekedCharacter.			peekedCharacter := nil.			(self 				readInto: collection 				startingAt: offset + 1				count: requestedCount - 1) + 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!skip: count	count timesRepeat: [ self next ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!upTo: anObject 		^ self collectionSpecies 		streamContents: [ :out | | element |			[ self atEnd or: [ (element := self next) = anObject ] ] whileFalse: [ 				out nextPut: element ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!upToEnd	^ self collectionSpecies		streamContents: [ :collectionStream | 			[ self atEnd ] whileFalse: [ collectionStream nextPut: self next ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2015 22:56'!wrappedStream	^ stream! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 7/17/2015 15:30'!consumeComment	stream peek = $/ ifTrue: [ self consumeToEOL ].	stream peek = $* ifTrue: [ self consumeToCommentEnd ]! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/8/2015 23:21'!consumeToCommentEnd	[ stream atEnd or: [ stream next = $* and: [ stream peekFor: $/ ] ] ] whileFalse! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/8/2015 23:11'!consumeToEOL	| eol char |	eol := false.	[ eol ] whileFalse: [ 		char := stream next.		(char isNil or: [ char = Character lf ])			ifTrue: [ eol := true ]			ifFalse: [ 				char = Character cr					ifTrue: [ 						eol := true.						stream peekFor: Character lf ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 7/17/2015 14:21'!escape	"Return true when we previously read a backslash escape inside a string, 	so that the next string delimiter should be returned as is"		^ escape = true! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 7/17/2015 15:31'!handleStringDelimiter: char	self escape		ifTrue: [ escape := false ]		ifFalse: [ 			self insideString				ifTrue: [ 					char = delimiter						ifTrue: [ delimiter := nil ] ]				ifFalse: [ delimiter := char ] ].	^ char! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 7/17/2015 14:21'!insideString	"Return true when we are currently inside a string where comments should be ignored."		^ (delimiter = $') | (delimiter = $")! !!STONCStyleCommentsSkipStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 7/17/2015 15:32'!nextNonCommentChar	| char |	char := stream next.	(self insideString and: [ char = $\ ])		ifTrue: [ 			escape := true. 			^ char ].	(char = $') | (char = $")		ifTrue: [ 			^ self handleStringDelimiter: char ].	escape := false. 	^ (char = $/ and: [ self insideString not ])		ifTrue: [ 			self consumeComment.			stream next ]		ifFalse: [ char ]! !!STONCStyleCommentsSkipStream class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/8/2015 22:58'!on: readStream	^ self new		on: readStream;		yourself! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:28'!fromStream: stream	^ STON fromStream: stream! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:28'!fromString: string	^ STON fromString: string! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:30'!put: object onStream: stream	STON put: object asJsonOnStream: stream! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:30'!put: object onStreamPretty: stream	STON put: object asJsonOnStreamPretty: stream! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:30'!toString: object	^ STON toJsonString: object! !!STONJSON class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 3/15/2016 14:30'!toStringPretty: object	^ STON toJsonStringPretty: object! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 8/12/2014 14:39'!acceptUnknownClasses: boolean	acceptUnknownClasses := boolean! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 10/24/2016 10:26'!allowComplexMapKeys: boolean	"This is a no-op, this used to be an option, but it is now always enabled"! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/14/2012 20:26'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/26/2015 23:39'!convertNewLines: boolean	"When true, any newline CR, LF or CRLF read unescaped inside strings or symbols 	will be converted to the newline convention chosen, see #newLine:	The default is false, not doing any convertions."		convertNewLines := boolean! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 10/24/2016 10:25'!initialize	super initialize.	objects := IdentityDictionary new.	classes := IdentityDictionary new.	acceptUnknownClasses := convertNewLines := false.	newLine := String cr.	unresolvedReferences := 0! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/26/2015 22:48'!newLine: string	"Set the newline convention to be used when converting newlines, see #convertNewLines"		newLine := string ! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/14/2012 20:26'!on: aReadStream	readStream := aReadStream! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/14/2016 13:57'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ]! !!STONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 10/25/2012 17:37'!reset	unresolvedReferences := 0.	objects removeAll! !!STONReader methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/7/2012 13:49'!atEnd	^ readStream atEnd! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/6/2012 20:59'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ readStream next ]! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/7/2012 10:33'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/12/2012 19:27'!isClassChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' includes: char! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/12/2012 19:27'!isClassStartChar: char	^ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' includes: char! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/12/2012 19:28'!isSimpleSymbolChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./' includes: char! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/20/2016 20:16'!lookupClass: name	Smalltalk globals 		at: name 		ifPresent: [ :class | ^ class ].	^ classes 		at: name 		ifAbsentPut: [			Object allSubclasses 				detect: [ :class | class isMeta not and: [ class stonName = name ]  ]				ifNone: [ NotFound signalFor: name ] ]	! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:57'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:54'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/18/2012 20:54'!newReference	| index reference |	index := objects size + 1.	reference := STONReference index: index.	objects at: index put: reference.	^ reference! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 20:06'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 20:06'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 20:06'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/14/2016 13:43'!processSubObjectsOf: object	| unresolvedReferencesCount |	unresolvedReferencesCount := unresolvedReferences.	object stonProcessSubObjects: [ :each | 		each isStonReference			ifTrue: [ self resolveReference: each ]			ifFalse: [ 				each stonContainSubObjects					ifTrue: [ self processSubObjectsOf: each ]					ifFalse: [ each ] ] ].	unresolvedReferencesCount > unresolvedReferences		ifTrue: [ object stonPostReferenceResolution ].	^ object! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/14/2016 13:07'!resolveReference: reference	unresolvedReferences := unresolvedReferences - 1.	^ self resolveReferenceIndex: reference index! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/18/2012 21:03'!resolveReferenceIndex: index	^ objects at: index! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/18/2012 21:01'!setReference: reference to: object	objects at: reference index put: object! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/16/2012 11:10'!storeReference: object	| index |	index := objects size + 1.	objects at: index put: object.	^ index! !!STONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/9/2012 17:23'!stringStreamContents: block	stringStream ifNil: [ 		stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!STONReader methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 12/13/2013 16:13'!error: aString	| streamPosition |	"Remain compatible with streams that don't understand #position"	streamPosition := [ readStream position ]		on: MessageNotUnderstood do: [ nil ].	^ STONReaderError signal: aString streamPosition: streamPosition! !!STONReader methodsFor: 'public' stamp: 'SvenVanCaekenberghe 4/14/2016 13:57'!next	| object |	self consumeWhitespace.	object := self parseValue.	unresolvedReferences > 0		ifTrue: [ self processSubObjectsOf: object ].	unresolvedReferences = 0		ifFalse: [ self error: 'Inconsistent reference resolution' ].	^ object! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 4/26/2015 22:40'!parseCharacter	| char |	^ (char := readStream next) = $\		ifTrue: [ self parseEscapedCharacter ]		ifFalse: [ char ]! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 4/26/2015 23:02'!parseCharacterConvertingNewLinesOn: writeStream	| char |	(char := readStream next) = $\		ifTrue: [ writeStream nextPut: self parseEscapedCharacter ]		ifFalse: [ 			char = Character lf 				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr 						ifTrue: [ 							readStream peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ writeStream nextPut: char ] ] ]! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 1/15/2012 11:28'!parseCharacterHexDigit	| digit |	readStream atEnd ifFalse: [ 		digit := readStream next asInteger.		(digit between: "$0" 48 and: "$9" 57)			ifTrue: [ ^ digit - 48 ].		(digit between: "$A" 65 and: "$F" 70)			ifTrue: [ ^ digit - 55 ].		(digit between: "$a" 97 and: "$f" 102)			ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 5/29/2012 21:13'!parseClass	| className |	className := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isClassChar: readStream peek ] ] whileTrue: [ 			stream nextPut: readStream next ] ].	self consumeWhitespace.	^ self lookupClass: className asSymbol	! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 5/7/2012 13:16'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			readStream next.			(readStream peek = $i)				ifTrue: [					self match: 'il' do: [ block value: nil ] ].			(readStream peek = $u)				ifTrue: [					self match: 'ull' do: [ block value: nil ] ] ]		! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 4/26/2015 22:14'!parseEscapedCharacter	| char |	char := readStream next.	(#($' $" $/ $\) includes: char)		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char).	^ char! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	^ 10 raisedTo: number! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 1/15/2012 10:52'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [		number := 10 * number + readStream next digitValue.		power := power * 10.0 ].	^ number / power! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 5/29/2012 21:13'!parseNumberInteger	| number |	number := 0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [ 		number := 10 * number + readStream next digitValue ].	^ number! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 5/28/2015 14:13'!parseReference	| index |	self expectChar: $@.	index := self parseNumberInteger.	self consumeWhitespace.	unresolvedReferences := unresolvedReferences + 1.	^ STONReference index: index! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 2/29/2012 21:50'!parseString	^ self parseStringInternal! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 4/26/2015 23:39'!parseStringInternal	| result delimiter |	delimiter := readStream next.	(delimiter = $' or: [ delimiter = $" ])		ifFalse: [ self error: ''' or " expected' ].	result := self		stringStreamContents: [ :stream | 			convertNewLines				ifTrue: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ self parseCharacterConvertingNewLinesOn: stream ] ]				ifFalse: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ stream nextPut: self parseCharacter ] ] ].	self expectChar: delimiter.	^ result! !!STONReader methodsFor: 'parsing-internal' stamp: 'SvenVanCaekenberghe 5/7/2012 10:42'!parseSymbol	| string |	self expectChar: $#.	readStream peek = $'		ifTrue: [ ^ self parseStringInternal asSymbol ].	string := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isSimpleSymbolChar: readStream peek ] ] whileTrue: [			stream nextPut: readStream next ] ].	string isEmpty		ifFalse: [ 			self consumeWhitespace.			^ string asSymbol ].	self error: 'unexpected input'! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 2/12/2012 15:21'!parseList	| reference array |	reference := self newReference.	array := STON listClass streamContents: [ :stream |		self parseListDo: [ :each | stream nextPut: each ] ].	self setReference: reference to: array.	^ array! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 11/27/2014 10:58'!parseListDo: block	| index |	self expectChar: $[.	(self matchChar: $]) ifTrue: [ ^ self ]. "short cut for empty lists"	index := 1.	[ readStream atEnd ] whileFalse: [		block cull: self parseValue cull: index.		(self matchChar: $]) ifTrue: [ ^ self ].		index := index + 1.		self expectChar: $, ].	self error: 'end of list expected'! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 2/12/2012 15:55'!parseListSingleton	| value |	value := nil.	self parseListDo: [ :each :index |		index = 1 ifTrue: [ value := each ] ].	^ value! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 2/12/2012 15:22'!parseMap	| map |	map := STON mapClass new.	self storeReference: map.	self parseMapDo: [ :key :value |		map at: key put: value ].	^ map! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 10/24/2016 10:27'!parseMapDo: block	self expectChar: ${.	(self matchChar: $}) ifTrue: [ ^ self ]. "short cut for empty maps"	[ readStream atEnd ] whileFalse: [ | name value |		name := self parseSimpleValue.		self expectChar: $:.		value := self parseValue.		block value: name value: value.		"The above is a more efficient way to say 'self parseValue' and using the returned association"		(self matchChar: $}) ifTrue: [ ^ self ].		self expectChar: $, ].	self error: 'end of map expected'! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/28/2015 15:31'!parseNamedInstVarsFor: anObject	self parseMapDo: [ :instVarName :value |		anObject instVarNamed: instVarName put: value ]! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 8/12/2014 15:04'!parseObject	| targetClass reference object |	[		reference := self newReference.		targetClass := self parseClass.		object := targetClass fromSton: self .		self setReference: reference to: object ]		on: NotFound 		do: [ :notFound |			acceptUnknownClasses 				ifTrue: [ 					object := STON mapClass new.					self storeReference: object.					self parseMapDo: [ :key :value |						object at: key put: value ].					object at: STON classNameKey put: notFound object ]				ifFalse: [ self error: 'Cannot resolve class named ', notFound object printString ] ].	^ object! !!STONReader methodsFor: 'parsing' stamp: 'ChristopheDemarey 11/6/2014 15:28'!parseSimpleValue	| char |	readStream atEnd ifFalse: [ 		(self isClassStartChar: (char := readStream peek)) 			ifTrue: [ ^ self parseObject ].		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		(char = $' or: [ char = $" ])			ifTrue: [ ^ self parseString ].		char = $#			ifTrue: [ ^ self parseSymbol ].		char = $@			ifTrue: [ ^ self parseReference ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input'! !!STONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 10/24/2016 10:27'!parseValue	| value |	value := self parseSimpleValue.	^ (self matchChar: $:)		ifTrue: [ STON associationClass key: value value: self parseValue ]		ifFalse: [ value ]! !!STONReader class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 1/14/2012 20:25'!on: readStream	^ self new		on: readStream;		yourself! !!STONReaderError methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/13/2013 16:12'!messageText	^ streamPosition 		ifNil: [ 			super messageText ] 		ifNotNil: [ :pos | 			'At character {1}: {2}' format: 				(Array with: streamPosition with: super messageText) ]! !!STONReaderError methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 10:00'!streamPosition	^ streamPosition! !!STONReaderError methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 10:00'!streamPosition: aNumber	streamPosition := aNumber! !!STONReaderError class methodsFor: 'instance creation' stamp: 'DamienCassou 12/9/2013 10:04'!signal: aString streamPosition: streamPosition 	^ self new		streamPosition: streamPosition;		signal: aString;		yourself! !!STONReference methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/18/2012 20:23'!= anObject	^ self class == anObject class and: [ self index = anObject index ]! !!STONReference methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/18/2012 20:22'!hash	^ index hash! !!STONReference methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/18/2012 19:35'!index	^ index! !!STONReference methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/18/2012 19:35'!index: integer	index := integer! !!STONReference methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/18/2012 20:22'!isStonReference	^ true! !!STONReference methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 11/28/2012 21:06'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: index; nextPut: $)! !!STONReference class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 1/18/2012 19:37'!index: integer	^ self new		index: integer;		yourself! !!STONStreamWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/24/2012 09:30'!initialize	super initialize.	first := true! !!STONStreamWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/24/2012 09:29'!on: stonWriter	writer := stonWriter! !!STONListWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:03'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer listElementSeparator ].	writer nextPut: anObject! !!STONMapWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:03'!at: key put: value	first ifTrue: [ first := false ] ifFalse: [ writer mapElementSeparator ].	writer encodeKey: key value: value! !!STONShortListWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 2/12/2012 15:49'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer shortListElementSeparator ].	writer nextPut: anObject! !!STONStreamWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 1/24/2012 09:29'!on: stonWriter	^ self new		on: stonWriter;		yourself! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 7/2/2015 15:11'!asciiOnly: boolean	asciiOnly := boolean! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/14/2012 15:37'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 7/2/2015 15:11'!initialize	super initialize.	prettyPrint := false.	newLine := String cr.	level := 0.	referencePolicy := #normal.	jsonMode := keepNewLines := asciiOnly := false.	objects := IdentityDictionary new! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/27/2012 13:53'!jsonMode: boolean	jsonMode := boolean! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/26/2015 23:30'!keepNewLines: boolean	"If true, any newline CR, LF or CRLF inside strings or symbols will not be escaped	but will instead be converted to the newline convention chosen, see #newLine:	The default is false, where CR, LF or CRLF will be enscaped unchanged."		keepNewLines := boolean! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/26/2015 23:34'!newLine: string	"The sequence to use when ending a line, either CR, LF or CRLF"		newLine := string! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!on: aWriteStream	writeStream := aWriteStream! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/29/2012 15:54'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ].! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/14/2012 15:36'!prettyPrint: boolean	prettyPrint := boolean! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!referencePolicy: policy	self assert: ( #(#normal #ignore #error) includes: policy ).	referencePolicy := policy! !!STONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 1/14/2012 15:37'!reset	objects removeAll! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/19/2016 21:16'!encodeCharacter: char	| code encoding |	"STONCharacters contains for the lower 127 characters (codes 0 to 126) either nil (unknown), 	#pass (output as is, clean ASCII characters) or a full escape string"	((code := char codePoint) < 127 and: [ (encoding := STONCharacters at: code + 1) notNil ])		ifTrue: [ 			(encoding = #pass or: [ jsonMode and: [ char = $' ] ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ writeStream nextPutAll: encoding ] ]		ifFalse: [			"always escape Latin1 C1 controls, or when asciiOnly is true" 			(code > 16r9F and: [ asciiOnly not ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ self escapeUnicode: code ] ]! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/23/2012 11:32'!encodeKey: key value: value	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/26/2015 23:17'!encodeString: string	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ]).	keepNewLines		ifTrue: [ 			self encodeStringKeepingNewLines: string ]		ifFalse: [ 			string do: [ :each | self encodeCharacter: each ] ].	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ])! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/26/2015 23:16'!encodeStringKeepingNewLines: string	| input char |	input := string readStream.	[ input atEnd ]		whileFalse: [ 			char := input next.			char = Character lf				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr						ifTrue: [ 							input peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ self encodeCharacter: char ] ] ]! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 21:06'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 11:26'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/23/2012 11:12'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/15/2014 13:35'!isSimpleSymbol: symbol	symbol isEmpty ifTrue: [ ^ false ].	^ (symbol class 		findFirstInString: symbol 		inSet: STONSimpleSymbolCharacters 		startingAt: 1) = 0! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/7/2013 10:39'!newlineIndent	prettyPrint ifTrue: [ 		writeStream nextPutAll: newLine.		level timesRepeat: [ writeStream tab ] ]! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/23/2012 11:18'!prettyPrintSpace	prettyPrint ifTrue: [ writeStream space ]! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/29/2012 12:23:33'!shortListElementSeparator	writeStream nextPut: $,.	self prettyPrintSpace! !!STONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/28/2015 15:04'!with: object do: block	| index |	referencePolicy = #ignore 		ifTrue: [ ^ block value ].	(index := objects at: object ifAbsent: [ nil ]) notNil		ifTrue: [			referencePolicy = #error				ifTrue: [ ^ self error: 'shared reference detected' ].			self writeReference: index ]		ifFalse: [			index := objects size + 1.			objects at: object put: index.			block value ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/5/2012 16:56'!encodeList: elements	writeStream nextPut: $[.	elements isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				elements 					do: [ :each | self nextPut: each ]					separatedBy: [ self listElementSeparator ] ].			self newlineIndent ].	writeStream nextPut: $]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/5/2012 16:56'!encodeMap: pairs	| first |	first := true.	writeStream nextPut: ${.	pairs isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				pairs keysAndValuesDo: [ :key :value |					first 						ifTrue: [ first := false ] 						ifFalse: [ self mapElementSeparator ].					self encodeKey: key value: value ] ].			self newlineIndent ].	writeStream nextPut: $}! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2016 10:22'!writeAssociation: association	jsonMode		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self 		encodeKey: association key 		value: association value! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/14/2012 15:51'!writeBoolean: boolean	writeStream print: boolean! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/14/2012 16:05'!writeFloat: float	writeStream print: float! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/14/2012 15:48'!writeInteger: integer	writeStream print: integer! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:00'!writeList: collection	self with: collection do: [ 		self encodeList: collection ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:01'!writeMap: hashedCollection	self with: hashedCollection do: [ 		self encodeMap: hashedCollection ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 4/27/2012 13:50'!writeNull	jsonMode		ifTrue: [ writeStream nextPutAll: 'null' ]		ifFalse: [ writeStream print: nil ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 11/27/2014 11:08'!writeObject: anObject	| instanceVariableNames |	(instanceVariableNames := anObject class stonAllInstVarNames) isEmpty		ifTrue: [ 			self writeObject: anObject do: [ self encodeMap: #() ] ]		ifFalse: [ 			self writeObject: anObject streamMap: [ :dictionary | 				instanceVariableNames do: [ :each | 					(anObject instVarNamed: each)						ifNotNil: [ :value | 							dictionary at: each asSymbol put: value ]						ifNil: [ 							anObject stonShouldWriteNilInstVars 								ifTrue: [ dictionary at: each asSymbol put: nil ] ] ] ] ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/28/2015 15:04'!writeObject: anObject do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		writeStream nextPutAll: anObject class stonName.		self prettyPrintSpace.		block value ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 2/12/2012 20:02'!writeObject: object listSingleton: element	self writeObject: object do: [		writeStream nextPut: $[.		self 			prettyPrintSpace;			nextPut: element;			prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:02'!writeObject: object streamList: block	self writeObject: object do: [ | listWriter |		listWriter := STONListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self newlineIndent.			block value: listWriter ].		self newlineIndent.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:02'!writeObject: object streamMap: block	self writeObject: object do: [ | mapWriter |		mapWriter := STONMapWriter on: self.		writeStream nextPut: ${.		self indentedDo: [			self newlineIndent.			block value: mapWriter ].		self newlineIndent.		writeStream nextPut: $} ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/24/2012 10:02'!writeObject: object streamShortList: block	self writeObject: object do: [ | listWriter |		listWriter := STONShortListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self prettyPrintSpace.			block value: listWriter ].		self prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 1/14/2012 17:29'!writeReference: index	writeStream		nextPut: $@;		print: index! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 2/29/2012 21:49'!writeString: string	self encodeString: string! !!STONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 4/27/2012 13:52'!writeSymbol: symbol	jsonMode		ifTrue: [			self writeString: symbol ]		ifFalse: [			writeStream nextPut: $#.			(self isSimpleSymbol: symbol)				ifTrue: [					writeStream nextPutAll: symbol ]				ifFalse: [					self encodeString: symbol ] ]! !!STONWriter methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 5/28/2015 15:02'!error: aString	^ STONWriterError signal: aString! !!STONWriter methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/14/2012 15:47'!nextPut: anObject	anObject stonOn: self! !!STONWriter class methodsFor: 'class initialization' stamp: 'SvenVanCaekenberghe 11/19/2016 21:14'!initialize	"Modification timestamp 20161119"		self initializeSTONCharacters.	self initializeSTONSimpleSymbolCharacters! !!STONWriter class methodsFor: 'class initialization' stamp: 'SvenVanCaekenberghe 11/19/2016 21:35'!initializeSTONCharacters	| escapes |	STONCharacters := Array new: 127.	32 to: 126 do: [ :each | 		STONCharacters at: each + 1 put: #pass ].	escapes := #( 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 34 '\"' 39 '\''' 47 '\/' 92 '\\' ).	escapes pairsDo: [ :code :escape | 		STONCharacters at: code + 1 put: escape ]! !!STONWriter class methodsFor: 'class initialization' stamp: 'SvenVanCaekenberghe 2/14/2012 17:50'!initializeSTONSimpleSymbolCharacters	"STONSimpleSymbolCharacters asArray collectWithIndex: [ :each :index |		each isZero ifTrue: [ (index - 1) asCharacter ] ]."			STONSimpleSymbolCharacters := ByteArray new: 256 withAll: 1.	1 to: 256 do: [ :each | | char |		char := (each - 1) asCharacter.		(self isSimpleSymbolChar: char)			ifTrue: [ 				STONSimpleSymbolCharacters at: each put: 0 ] ]! !!STONWriter class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/14/2012 17:49'!isSimpleSymbolChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./' includes: char! !!STONWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 1/14/2012 15:48'!on: writeStream	^ self new		on: writeStream;		yourself! !!SequenceableCollection methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/8/2012 19:22'!stonOn: stonWriter	self class == STON listClass		ifTrue: [ stonWriter writeList: self ]		ifFalse: [ super stonOn: stonWriter ]! !!ByteArray methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:25'!stonContainSubObjects 	^ false! !!ByteArray methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 20:02'!stonOn: stonWriter	"Use a hex representation"		stonWriter writeObject: self listSingleton: self hex! !!Interval methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/24/2016 13:56'!fromSton: stonReader	stonReader parseNamedInstVarsFor: self! !!Interval methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/24/2016 13:56'!stonOn: stonWriter	stonWriter writeObject: self! !!SequenceableCollection class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 15:07'!fromSton: stonReader	^ self streamContents: [ :stream |		stonReader parseListDo: [ :each |			stream nextPut: each ] ]! !!ByteArray class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 15:16'!fromSton: stonReader	^ self readHexFrom: stonReader parseListSingleton! !!Interval class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/24/2016 13:57'!fromSton: stonReader	^ self new		fromSton: stonReader;		yourself! !!RunArray class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 3/23/2014 18:51'!fromSton: stonReader	^ self new		fromSton: stonReader;		yourself! !!Set methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/14/2016 13:55'!stonPostReferenceResolution	"When references were resolved in me, the hash of my elements might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !!String methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:27'!stonContainSubObjects 	^ false! !!String methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 16:22'!stonOn: stonWriter	stonWriter writeString: self! !!Symbol methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 16:22'!stonOn: stonWriter	stonWriter writeSymbol: self! !!Text class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 3/23/2014 18:48'!fromSton: stonReader	^ self new		fromSton: stonReader;		yourself! !!Time methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:26'!stonContainSubObjects 	^ false! !!Time methodsFor: '*ston-core' stamp: 'fn 11/25/2016 16:48'!stonOn: stonWriter	"Use an ISO style HH:MM:SS.N representation (with optional nanoseconds)"	 	stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream | self stonPrint24: stream ])! !!Time class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 15:17'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!buildPathFrom: pathCollection    ^ String        streamContents: [ :stream | pathCollection do: [ :element | stream nextPutAll: element ] separatedBy: [ stream nextPut: self pathNameDelimiter ] ]! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!default    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!deleteAll: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!directoryExists: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!directoryFromPath: directoryPath    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!directoryFromPath: directoryPath relativeTo: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!directoryName: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!directoryPathString: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!ensureDirectoryExists: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!ensureFilePathExists: fileNameOrPath relativeTo: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!fileName: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!filePathExists: filePath relativeTo: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!parentDirectoryOf: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!pathNameDelimiter    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!readStreamFor: filePath do: aBlock    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!readStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!resolvePath: path in: aDirectory    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'utilities' stamp: '12/9/2018 20:41:24'!writeStreamFor: filePath in: aDirectory do: aBlock    self subclassResponsibility! !!TonelFileUtils class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!current    ^ Current! !!TonelFileUtils class methodsFor: 'initialization' stamp: '12/9/2018 20:41:24'!install    Current := self! !!TonelParser methodsFor: 'private' stamp: 'jr 12/9/2018 19:44'!cleanSelector: aString	"BEWARE: I'm doing some heave assumptions here: I'm removing just ONE space (in case there 	 is one) because I expect this to be a file generated by tonel, and tonel adds one space 	 before start with the method body to make the format more readable. 	 But of course this is not very good :("	^ (aString last = Character space		ifTrue: [ aString allButLast ]		ifFalse: [ aString ]) 		withoutLeadingBlanks! !!TonelParser methodsFor: 'private' stamp: 'jr 12/9/2018 19:44'!extractSelector: aString	| separators selectorStream keywords |		separators := { 		Character space. 		Character tab. 		Character lf. 		Character newPage. 		Character cr. 		$:}.	keywords := Array new writeStream.	selectorStream := (self removeComments: aString) readStream.	[ selectorStream atEnd ]	whileFalse: [ | word ch |		word := String new writeStream.		[ selectorStream atEnd not and: [ (separators includes: (ch := selectorStream next)) not ] ]		whileTrue: [ word nextPut: ch ].		ch = $: ifTrue: [ word nextPut: ch ]. 		word contents withBlanksTrimmed ifNotEmpty: [ :v | keywords nextPut: v ] ].	keywords := keywords contents.	^ (keywords size <= 2 		ifTrue: [ keywords first]		ifFalse: [ (keywords pairsCollect: [ :keyword :argument | keyword ]) join ])		asSymbol! !!TonelParser methodsFor: 'private' stamp: '12/9/2018 20:41:24'!removeComments: original	| newStream readStream inComment |		newStream := original copy writeStream.	readStream := original readStream.	inComment := false.		[ readStream atEnd ] whileFalse: [ | ch |				ch := readStream next.				(ch = $") ifTrue:[			inComment := inComment not.			ch := readStream next.		].				(inComment or:[ ch isNil]) ifFalse: [ newStream nextPut: ch	 ]	].		^ newStream contents! !!TonelParser methodsFor: 'private' stamp: '12/9/2018 20:41:24'!validateStatelessTraitIsBeingRead: metadata	| vars |		vars := Set new.	vars 		addAll: (metadata at: #instVars ifAbsent: [ #() ]);		addAll: (metadata at: #classInstVars ifAbsent: [ #() ]).		vars ifNotEmpty: [ 		self error: 'Trying to load a stateful trait in a stateless version.' ]! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!comment	^ (TonelCommentScanner on: stream) scan! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!document	^ { 	self typeDef.	self methodDefList.	 } 	flattened	select: #notNil! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!metadata	| result ch count |		result := String new writeStream.	count := 0.	stream peek = ${ ifFalse: [ TonelParseError signal: 'Can''t parse metadata' ].		[ stream atEnd ]	whileFalse: [ 		ch := stream next.		result nextPut: ch.		ch = ${ ifTrue: [ count := count +1 ].		ch = $} ifTrue: [ count := count -1 ].		count = 0 ifTrue: [ ^ STON fromString: result contents ]].	TonelParseError signal: 'Can''t parse metadata'! !!TonelParser methodsFor: 'parsing' stamp: 'jr 12/9/2018 19:44'!method	| type selector |		type := self untilIncluding: '>>'.	selector := self cleanSelector: (self untilExcluding: '[').	type := type withBlanksTrimmed subStrings: ' '.	type size = 1 ifTrue: [ type := type copyWith: nil ].	^ { 		type.		selector.	}! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!methodBody	"I read a methodbody (what is inside [ ... ])"	^ (TonelSourceScanner on: stream) scan			! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!methodDef	^ self newMethodDefinitionFrom: { 		self separator.		self try: [ self metadata ]. 		self separator. 		self method. 		self methodBody 	}! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!methodDefList	| result |		self separator. "to arrive to the end of the file in case there are no methods"	result := Array new writeStream.	[ stream atEnd ]	whileFalse: [ 		result nextPut: self methodDef.		"skip possible spaces at the end"		self separator ].		^ result contents! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!separator	[ stream atEnd not and: [ self isSeparator: stream peek ] ]	whileTrue: [ stream next ].	^ nil! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!type	self try: [ self word: 'Class' ] onSuccess: [ :word | ^ word  ].	self try: [ self word: 'Trait' ] onSuccess: [ :word | ^ word  ].	self try: [ self word: 'Extension' ] onSuccess: [ :word | ^ word  ].		"at end"	TonelParseError signal: 'Can''t parse type.'	! !!TonelParser methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!typeDef	^ self newTypeDefinitionFrom: { 		self separator.		self try: [ self comment ]. 		self separator. 		self type. 		self separator. 		self try: [ self metadata ] 	} 			! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!definitionForType: aString 	aString = TonelWriter classLabel ifTrue: [ ^ MCClassDefinition ].	aString = TonelWriter traitLabel ifTrue: [ ^ MCTraitDefinition ].		aString = TonelWriter extensionLabel ifTrue: [ ^ nil ].		TonelParseError signal: 'Unknown type declaration.'! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!newClassDefinitionFrom: anArray	| metadata |	metadata := anArray sixth.	^ MCClassDefinition		name: (metadata at: #name)		superclassName: (metadata at: #superclass)		traitComposition: (metadata at: #traits ifAbsent: [ '{}' ])		classTraitComposition: (metadata at: #classTraits ifAbsent: [ '{}' ])		category: (metadata at: #category)		instVarNames: (metadata at: #instVars ifAbsent: [ #() ])		classVarNames: (metadata at: 'classVars' ifAbsent: [ #() ])		poolDictionaryNames: (metadata at: 'pools' ifAbsent: [ #() ])		classInstVarNames: (metadata at: 'classInstVars' ifAbsent: [ #() ])		type: (metadata at: #type ifAbsent: [ #normal ]) asSymbol		comment: (anArray second ifNil: [ '' ])		commentStamp: nil! !!TonelParser methodsFor: 'private factory' stamp: 'jr 12/9/2018 19:44'!newMethodDefinitionFrom: anArray	| metadata className meta selector source  |		metadata := anArray second ifNil: [ Dictionary new ].	className := anArray fourth first first.	meta := anArray fourth first second notNil.	selector := self extractSelector: anArray fourth second withBlanksTrimmed.	source := String streamContents: [ :s | 		s << anArray fourth second.		anArray fifth ifNotEmpty: [ :src | s << src ] ].		^ MCMethodDefinition		className: className		classIsMeta: meta		selector: selector		category: (metadata at: #category ifAbsent: [ '' ]) 		timeStamp: nil		source: source! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!newStatefulTraitDefinitionFrom: anArray	| metadata |		metadata := anArray sixth.	^ MCTraitDefinition			name: (metadata at: #name)			traitComposition: (metadata at: #traits ifAbsent: [ '{}' ])			category: (metadata at: #category)			instVarNames: (metadata at: #instVars ifAbsent: [ #() ])			classInstVarNames: (metadata at: #classInstVars ifAbsent: [ #() ])			comment: (anArray second ifNil: [ '' ])			commentStamp: nil! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!newStatelessTraitDefinitionFrom: anArray	| metadata |		metadata := anArray sixth.		self validateStatelessTraitIsBeingRead: metadata.		^ MCTraitDefinition			name: (metadata at: #name)			traitComposition: (metadata at: #traits ifAbsent: [ '{}' ])			category: (metadata at: #category)			comment: (anArray second ifNil: [ '' ])			commentStamp: nil! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!newTraitDefinitionFrom: anArray	| metadata traitDefs |		metadata := anArray sixth.	traitDefs := { 		self hasStatefulTraits 			ifTrue: [ self newStatefulTraitDefinitionFrom: anArray ]			ifFalse: [ self newStatelessTraitDefinitionFrom: anArray ] }.				metadata 		at: #classTraits		ifPresent: [ :classTraits |			traitDefs := traitDefs copyWith: (MCClassTraitDefinition 				baseTraitName: (metadata at: #name) 				classTraitComposition: classTraits				category: (metadata at: #category)) ].				^ traitDefs! !!TonelParser methodsFor: 'private factory' stamp: '12/9/2018 20:41:24'!newTypeDefinitionFrom: anArray	| typeClass |		typeClass := self definitionForType: anArray fourth.	typeClass = MCClassDefinition ifTrue: [ ^ self newClassDefinitionFrom: anArray ].	typeClass = MCTraitDefinition ifTrue: [ ^ self newTraitDefinitionFrom: anArray ].		"is extension, no type"	^ nil! !!TonelParser methodsFor: 'private testing' stamp: '12/9/2018 20:41:24'!hasStatefulTraits	"Pharo has stateful traits starting on version 7"		^ SystemVersion current major >= 7! !!TonelParser methodsFor: 'private testing' stamp: '12/9/2018 20:41:24'!isSeparator: aCharacter 	^ aCharacter isSeparator! !!TonelParser methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!start	^ self document! !!TonelParser methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!stream: aStream 	stream := aStream! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!try: aBlock	^ self 		try: aBlock 		onSuccess: [ :parsedValue | parsedValue ] 		onFailure: [ nil ]! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!try: aBlock onFailure: failureBlock	^ self 		try: aBlock 		onSuccess: [ :parsedValue |  parsedValue ] 		onFailure: failureBlock! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!try: aBlock onSuccess: successBlock	^ self 		try: aBlock 		onSuccess: successBlock 		onFailure: [ nil ]! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!try: aBlock onSuccess: successBlock onFailure: failureBlock	| pos |		pos := stream position.	[ ^ successBlock value: aBlock value ]	on: TonelParseError 	do: [ :e | 		stream position: pos.		^ failureBlock value ]. 	! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!untilExcluding: aCollection	| result |	result := stream upToAll: aCollection.	stream position: stream position - aCollection size.	^ result! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!untilIncluding: aCollection	^ stream upToAll: aCollection! !!TonelParser methodsFor: 'private parsing' stamp: '12/9/2018 20:41:24'!word: aString	| result |	result := stream next: aString size.	result = aString		ifFalse: [ TonelParseError signal: 'Can''t parse ', aString ].	^ result! !!TonelParser class methodsFor: 'instance creation' stamp: '12/9/2018 20:41:24'!on: aStream 	^ self new 		stream: aStream;		yourself! !!TonelParser class methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!parseStream: aStream 	^ (self on: aStream) start! !!TonelParser class methodsFor: 'parsing' stamp: '12/9/2018 20:41:24'!parseString: aString 	^ self parseStream: aString readStream! !!TonelReader methodsFor: 'private' stamp: '12/9/2018 20:41:24'!canBeLoaded: aFileReference	| fileName |	fileName := self fileUtils fileName: aFileReference. 	^ fileName ~= 'package.st' and: [ fileName endsWith: '.st' ]! !!TonelReader methodsFor: 'private' stamp: '12/9/2018 20:41:24'!categoriesFrom: aCollection	^ ((aCollection select: #isClassDefinition)		collect: #category		as: Set)		sorted: [ :a :b | a < b ]! !!TonelReader methodsFor: 'private' stamp: '12/9/2018 20:41:24'!packageNameFromPackageDirectory    ^ packageDirectory basename! !!TonelReader methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!fileUtils	^ TonelFileUtils current! !!TonelReader methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!packageDirectory	^ packageDirectory! !!TonelReader methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!packageDirectory: aDirectoryName	packageDirectory := self fileUtils 		directoryFromPath: aDirectoryName 		relativeTo: stream! !!TonelReader methodsFor: 'loading' stamp: '12/9/2018 20:41:24'!loadDefinitions	| definitionOrders newDefinitions newCategories organization |		definitionOrders := self class definitionOrders.	newDefinitions := ((self packageDirectory entries		select: [ :each | self canBeLoaded: each ]) 		collect: [ :each | each readStreamDo: [ :s | TonelParser parseStream: s ] ])		flattened		sort: [ :a :b | (definitionOrders at: a class) < (definitionOrders at: b class) ].	newCategories := self categoriesFrom: newDefinitions.	(newCategories includes: self package name asSymbol)		ifFalse: [ newCategories := newCategories copyWithFirst: self package name ].	organization := MCOrganizationDefinition categories: newCategories.		definitions := (newDefinitions copyWithFirst: organization) sort! !!TonelReader methodsFor: 'loading' stamp: '12/9/2018 20:41:24'!loadDependencies	"There should not be dependencies"	dependencies := #()! !!TonelReader methodsFor: 'loading' stamp: '12/9/2018 20:41:24'!loadPackage	package := MCPackage named: self packageNameFromPackageDirectory! !!TonelReader methodsFor: 'loading' stamp: 'jr 1/1/2019 18:55'!loadVersionInfo	info := MCVersionInfo		name: self packageNameFromPackageDirectory, self class generatedVersionSuffix		id: UUID new		message: 'fabricated from a Tonel format repository'		date: Date today		time: Time now		author: ''		ancestors: #()		stepChildren: #()! !!TonelReader class methodsFor: 'testing' stamp: 'jr 1/2/2019 00:50'!canReadFileNamed: fileName	"We validate that fileName does not contains dot, but that's the only thing we can do 	 at this point."	| actualFileName |	actualFileName := TonelRepository directoryNameFromFileName: fileName.	^ actualFileName noneSatisfy: [ :each | each = $. ]! !!TonelReader class methodsFor: 'testing' stamp: 'jr 1/1/2019 18:54'!generatedVersionSuffix	^ '-tonel.1'! !!TonelReader class methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isAbstract	^ false! !!TonelReader class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!definitionOrders	"Used to sort definitions inside a snapshot"	^ Dictionary newFromPairs: { 		MCOrganizationDefinition. 	0.		MCMethodDefinition. 			1.		MCClassDefinition. 			2.		MCTraitDefinition. 			2.		MCClassTraitDefinition. 		3 }! !!TonelReader class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!extension	"This is needed because the implementation of MCCacheRepository assumes each package 	 has an extension (which is a lame implementation) and then we need to provide one. 	 Since tonel is not cached (because we have our oen cache in the form of a local repository), 	 we put something that will not be found anyway"	^ 'NOTUSED'		! !!TonelReader class methodsFor: 'reading' stamp: 'jr 1/2/2019 00:49'!on: parentDirectoryReference fileName: fileName	"I will anster a reader for the package stored in 			[repository]/parentDirectoryReference/packageName		This operation will NOT read the package, but resulting instance will be prepared	to doit, executing: #loadDefinitions"	| packageName |	packageName := TonelRepository directoryNameFromFileName: fileName.	^ (self on: parentDirectoryReference)		packageDirectory: packageName;		yourself! !!TonelRepository methodsFor: 'accessing' stamp: 'jr 1/2/2019 00:47'!allFileNames	^directory entries 		sort: [ :a :b | a name >= b name ];		replace: [ :ea | (self fileNameFromDirectory: ea asReference) asMCVersionName ]! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!allFileNamesForVersionNamed: aString	^ self 		filterFileNames: self readableFileNames 		forVersionNamed: aString! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!asRepositorySpecFor: aMetacelloMCProject    ^ aMetacelloMCProject repositorySpec        description: self description;        type: 'tonel';        yourself! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!basicStoreVersion: aVersion  TonelWriter 	fileOut: aVersion 	on: self directory! !!TonelRepository methodsFor: 'accessing' stamp: 'jr 1/1/2019 16:55'!directory: aDirectory	directory := aDirectory asFSReference! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!fileDirectoryOn: directoryPath	^ self fileUtils 		directoryFromPath: directoryPath 		relativeTo: self directory! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!fileUtils	^ TonelFileUtils current! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!filterFileNames: aCollection forVersionNamed: aString	^ aCollection select: [:ea | (self versionNameFromFileName: ea) = aString]! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!loadAllFileNames	^ super loadAllFileNames 		select: [ :each | 			self fileUtils 				filePathExists: each, '/package.st' 				relativeTo: self directory ]! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!packageDescriptionFromPackageDirectory: packageDirectory    | filename |    filename := self fileUtils directoryName: packageDirectory.    ^ {filename. 'tonel'. 1. filename}! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!packageDescriptionsFromReadableFileNames    ^ ((self readableFileNames 		collect: [ :each | self fileUtils directoryFromPath: each relativeTo: self directory ])		select: [ :each | self fileUtils directoryExists: each ])		collect: [ :each | self packageDescriptionFromPackageDirectory: each ]! !!TonelRepository methodsFor: 'accessing' stamp: 'jr 1/1/2019 16:36'!readableFileNames	| all cached new |	all := self allFileNames. "in disk"	all := all reject: [ :each | each beginsWith: '.' ].	cached := self cachedFileNames. "in memory"	new := all difference: cached.	^ (cached asArray, new) select: [:ea | self canReadFileNamed: ea]! !!TonelRepository methodsFor: 'accessing' stamp: 'jr 1/2/2019 00:39'!readableFileReferences	^ self readableFileNames collect: [ :each | self directoryFromFileName: each ]! !!TonelRepository methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!versionFrom: aVersionReferenceString    "until we no longer find .tree directories in the wild"   	^ self readableFileReferences		detect: [ :each | 			(self fileUtils directoryExists: each)			and: [ 				each basename = aVersionReferenceString 				or: [ (self versionInfoForPackageDirectory: each) name = aVersionReferenceString ] ] ]		ifFound: [ :packageDirectory | 			self loadVersionFromFileNamed: (self fileUtils directoryName: packageDirectory) ]		ifNone: [ 			nil ].! !!TonelRepository methodsFor: 'accessing' stamp: 'jr 1/2/2019 00:36'!versionFromFileNamed: aString	^ self versionFrom: aString! !!TonelRepository methodsFor: 'private-files' stamp: 'jr 1/2/2019 01:07'!canReadFileNamed: aString    ^ (self directoryFromFileName: aString) isDirectory! !!TonelRepository methodsFor: 'private-files' stamp: 'jr 1/2/2019 00:49'!directoryFromFileName: aString	"Answer the reference to the directory represented by the 'file name'."	^ self fileUtils		directoryFromPath: (self class directoryNameFromFileName: aString)		relativeTo: self directory! !!TonelRepository methodsFor: 'private-files' stamp: 'jr 1/2/2019 00:49'!fileNameFromDirectory: aDirectoryReference	"Answer the 'file name' for the directory which contains a package."	^ self class fileNameFromDirectory: aDirectoryReference! !!TonelRepository methodsFor: 'user interface' stamp: 'jr 1/1/2019 16:58'!description	^ directory fullName! !!TonelRepository methodsFor: 'metacello support' stamp: '12/9/2018 20:41:24'!goferVersionFrom: aVersionReference	"Simillar hack than FileTree repositories."	(self readableFileNames collect: [ :fileName | self fileDirectoryOn: fileName ])		do: [ :packageDirectory |			((self fileUtils directoryExists: packageDirectory )			and: [(self versionInfoForPackageDirectory: packageDirectory) name = aVersionReference name])				ifTrue: [ ^ self loadVersionFromFileNamed: (self fileUtils directoryName: packageDirectory) ] ].	^nil! !!TonelRepository methodsFor: 'actions' stamp: '12/9/2018 20:41:24'!readStreamForFileNamed: aString do: aBlock    ^ aBlock value: self directory! !!TonelRepository methodsFor: 'versions' stamp: '12/9/2018 20:41:24'!versionInfoForPackageDirectory: packageDirectory	^ ((MCReader readerClassForFileNamed: (self fileUtils directoryName: packageDirectory))		on: (self fileUtils parentDirectoryOf: packageDirectory)		fileName: (self fileUtils directoryName: packageDirectory))		loadVersionInfo;		info! !!TonelRepository methodsFor: 'versions' stamp: '12/9/2018 20:41:24'!versionInfoFromVersionNamed: aString	^ self versionInfoForPackageDirectory: (self fileDirectoryOn: aString)! !!TonelRepository methodsFor: 'versions' stamp: 'jr 1/2/2019 00:34'!versionNameFromFileName: aString	"Currently, the 'file names' are faked to be version names, so the MCFileRepositoryInspector can handle Tonel repositories."	^ aString! !!TonelRepository methodsFor: 'versions' stamp: '12/9/2018 20:41:24'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	(self allFileNamesForVersionNamed: aVersionInfo name)		ifNotEmpty: [ :aCollection | ^ self versionFromFileNamed: aCollection first ].	^ errorBlock value! !!TonelRepository class methodsFor: 'instance creation' stamp: '12/9/2018 20:41:24'!basicFromUrl: anUrl	"remove 'tonel://' and go"	^ self new directory: (anUrl asString allButFirst: self description size) asFileReference! !!TonelRepository class methodsFor: 'metacello support' stamp: '12/9/2018 20:41:24'!createRepositoryFromSpec: aRepositorySpec on: aPlatform	^ aPlatform createTonelRepository: aRepositorySpec! !!TonelRepository class methodsFor: 'metacello support' stamp: '12/9/2018 20:41:24'!isAvailableFor: type	^ type = 'tonel'! !!TonelRepository class methodsFor: 'metacello support' stamp: '12/9/2018 20:41:24'!isFiletreeAlternateFormat: aRepositorySpec	| location propRef |		location := (aRepositorySpec description allButFirst: ('filetree://' size)) asFileReference.	propRef := location / '.properties'.	propRef exists ifFalse: [ ^ false ].		^ propRef readStreamDo:[ :stream | 		((STONJSON fromStream: stream) at: #format ifAbsent: []) = #tonel ]! !!TonelRepository class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!description    ^ 'tonel://'! !!TonelRepository class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!urlSchemes	^ #(tonel)! !!TonelRepository class methodsFor: 'files' stamp: 'jr 1/2/2019 00:48'!directoryNameFromFileName: aString	"Answer the name of the directory represented by the 'file name'."	| suffix |	suffix := TonelReader generatedVersionSuffix.	(aString endsWith: suffix) ifFalse: [^ aString].	^ aString allButLast: suffix size! !!TonelRepository class methodsFor: 'files' stamp: 'jr 1/2/2019 00:47'!fileNameFromDirectory: aDirectoryReference	"Answer the 'file name' for the directory which contains a package."	^ aDirectoryReference basename, TonelReader generatedVersionSuffix! !!TonelSTONWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!aliases	^ aliases! !!TonelSTONWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!aliases: aDictionary	aliases := aDictionary! !!TonelSTONWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!stonNameFor: aClass	^ self aliases 		at: aClass 		ifAbsent: [ aClass stonName ]! !!TonelSTONWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!encodeMap: pairs	| first |	first := true.	writeStream nextPut: ${.	pairs isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				pairs size = 1 					ifTrue: [ self prettyPrintSpace ]					ifFalse: [ self newlineIndent ].				pairs keysAndValuesDo: [ :key :value |					first 						ifTrue: [ first := false ] 						ifFalse: [ self mapElementSeparator ].					self encodeKey: key value: value ] ].				pairs size = 1 					ifTrue: [ self prettyPrintSpace ]					ifFalse: [ self newlineIndent ] ].	writeStream nextPut: $}! !!TonelSTONWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!writeObject: anObject do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		(self stonNameFor: anObject class) ifNotNil: [ :stonName | 			writeStream nextPutAll: stonName.			self prettyPrintSpace ].		block value ]! !!TonelSTONWriter methodsFor: 'initialization' stamp: 'TonelWriterTest 12/12/2018 22:56'!initialize	super initialize.	self prettyPrint: true.	aliases := ({ OrderedDictionary -> nil } as: Dictionary)! !!TonelSTONWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!isSimpleSymbol: symbol	"Customize STON to only consider very clean symbols as literal, 	for all others err on the safe side and quote them."		symbol isEmpty ifTrue: [ ^ false ].	('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' includes: symbol first)		ifFalse: [ ^ false ].	^ symbol allSatisfy: [ :each | 		'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' includes: each ]! !!TonelScanner methodsFor: 'initialization' stamp: '12/9/2018 20:41:24'!initializeStream: aStream	self initialize.	stream := aStream! !!TonelScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isEnter: aCharacter	^ #(13 10) includes: aCharacter asciiValue! !!TonelScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isSeparator: aCharacter	^ aCharacter isSeparator! !!TonelScanner methodsFor: 'private' stamp: '12/9/2018 20:41:24'!removeFrom: aString enclosingStart: startChar end: endChar	^ self 		removeFrom: aString 		enclosingStart: startChar 		end: endChar		clean: #both! !!TonelScanner methodsFor: 'private' stamp: 'jr 12/9/2018 19:44'!removeFrom: aString enclosingStart: startChar end: endChar clean: cleanSymbol	"cleanSymbol can be #left, #right and #both" 	| nl result stop ch start end |		nl := String cr.	result := (aString withBlanksTrimmed withLineEndings: nl) readStream.	(result peek = startChar) 		ifFalse: [ TonelParseError signal: 'I cannot remove enclosing start' ].	result skip: 1.		(#(both left) includes: cleanSymbol) 		ifTrue: [ 			stop := nl size.			[ (stop > 0) and: [ self isSeparator: (ch := result peek) ] ]			whileTrue: [ 				(self isEnter: ch) ifTrue: [ stop := stop - 1 ].				result skip: 1 ] ].	start := result position.		result setToEnd.	result skip: -1.	(result peek = endChar) 		ifFalse: [ TonelParseError signal: 'I cannot remove enclosing end' ].	result skip: -1.	(#(both right) includes: cleanSymbol)		ifTrue: [ 			stop := nl size.			[ (stop > 0) and: [ self isSeparator: (ch := result peek) ] ]			whileTrue: [ 				(self isEnter: ch) ifTrue: [ stop := stop - 1 ].				result skip: -1. ] ].	end := result position.		^ result originalContents		copyFrom: start + 1 		to: end + 1! !!TonelScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scan 	self subclassResponsibility! !!TonelCommentScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scan	| result ch eatNext |		result := String new writeStream.	eatNext := false.	stream next = $" ifFalse: [ TonelParseError signal: 'Can''t parse comment' ].		[ stream atEnd not 		and: [ 				(ch := stream next) ~= $" 				or: [ eatNext := (stream peek = $") ] ] ]	whileTrue: [ 		result nextPut: ch.		eatNext ifTrue: [ 			stream skip: 1.			eatNext := false ] ].		self flag: #todo. "This is a hack to make my clean algoritm for bodies work also for 	comments. I need to refactor the 'eat enter' part out to use just that."	^ self 		removeFrom: '"',result contents,'"' withSqueakLineEndings		enclosingStart: $" 		end: $"! !!TonelScanner class methodsFor: 'instance creation' stamp: '12/9/2018 20:41:24'!new	self error: 'Use #on:'! !!TonelScanner class methodsFor: 'instance creation' stamp: '12/9/2018 20:41:24'!on: aStream	^ self basicNew 		initializeStream: aStream;		yourself! !!TonelSourceScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isStartingComment	"Comment start with a double quote in Smalltalk syntax"	^ char = $"! !!TonelSourceScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isStartingLiteralArray	"Literal array starts with a sharp sign followed by parenthesis in Smalltalk syntax"	^ char = $( and: [ prevChar = $# ]! !!TonelSourceScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isStartingLiteralCharacter	"A literal Character start with a dollar sign in Smalltalk syntax"  	^ char = $$! !!TonelSourceScanner methodsFor: 'testing' stamp: '12/9/2018 20:41:24'!isStartingString	"String start with single quote in Smalltalk syntax"	^ char = $'! !!TonelSourceScanner methodsFor: 'private' stamp: '12/9/2018 20:41:24'!prepareToScan	result := String new writeStream.	isFinished := false.	char := prevChar := nil.	count := 0	! !!TonelSourceScanner methodsFor: 'private' stamp: '12/9/2018 20:41:24'!readNext	prevChar := char.	result nextPut: (char := stream next)! !!TonelSourceScanner methodsFor: 'private' stamp: '12/9/2018 20:41:24'!readUntil: aBlock	[ stream atEnd ]	whileFalse: [		self readNext.		aBlock value ifTrue: [ ^ self ] ]! !!TonelSourceScanner methodsFor: 'private' stamp: '12/9/2018 20:41:24'!readUntilTermination: matchChar	| terminationCount |	"This is used to read sequences that start and finish with same character termination. 	 tipically, this is for strings and comments, but who knows what comes in the future."	terminationCount := 1.	self readUntil: [ 		char = matchChar ifTrue: [ terminationCount := terminationCount + 1 ].		terminationCount even and: [ stream peek ~= matchChar ] ]! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scan	self prepareToScan.		stream peek = $[ ifFalse: [ TonelParseError signal: 'Can''t parse method body' ].	[ stream atEnd or: [ isFinished ] ]	whileFalse: [ self scanNextChunk ].	isFinished ifTrue: [ 		"clean up to return"		^ self 			removeFrom: result contents withSqueakLineEndings			enclosingStart: $[ 			end: $]			clean: #right ].	TonelParseError signal: 'Can''t parse method body'! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanForBlock	| match |	match := false.	char = $[ ifTrue: [ 		count := count + 1.		match := true ].	char = $] ifTrue: [ 		count := count - 1.		match := true ].	isFinished := count = 0.	^match! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanForComment	self isStartingComment ifFalse: [ ^ false ]. 	self readUntilTermination: $".	^true! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanForLiteralArray	| literalCount |	self isStartingLiteralArray ifFalse: [ ^ false ]. 	literalCount := 1.	self readUntil: [		self scanForLiteralCharacter			or: [ self scanForString			or: [ self scanForComment			or: [ char = $( ifTrue: [ literalCount := literalCount + 1 ].					char = $) ifTrue: [ literalCount := literalCount - 1 ]]]].		literalCount = 0 ].	^true! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanForLiteralCharacter	self isStartingLiteralCharacter ifFalse: [ ^ false ]. 	self readNext.	^true! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanForString	self isStartingString ifFalse: [ ^ false ].	self readUntilTermination: $'.	^true! !!TonelSourceScanner methodsFor: 'scanning' stamp: '12/9/2018 20:41:24'!scanNextChunk	self readNext.		self scanForBlock or: [	self scanForComment or: [	self scanForString or: [	self scanForLiteralCharacter or: [	self scanForLiteralArray ]]]]! !!TonelUrl class methodsFor: 'constants' stamp: 'jr 12/9/2018 19:43'!schemeName	^ 'tonel'! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!classNameFor: aMethodDefinition parent: aClassDefinition	aClassDefinition ifNil: [ ^ aMethodDefinition fullClassName ].	^ aMethodDefinition classIsMeta		ifFalse: [ aMethodDefinition className ]		ifTrue: [ 			aClassDefinition isTraitDefinition				ifFalse: [aMethodDefinition className, ' class']				ifTrue: [aMethodDefinition className, ' classSide'] ]! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!createDefaultOrganizationFrom: aMCClassDefinition 	^ MCOrganizationDefinition categories: { aMCClassDefinition category }! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!fileNameFor: aClassDefinition	^ String streamContents: [ :stream | 		stream 			<< aClassDefinition className			<< '.' << (self typeOf: aClassDefinition) asLowercase			<< '.st'  ]! !!TonelWriter methodsFor: 'private' stamp: 'jr 12/9/2018 19:43'!newLine	 ^ Smalltalk os platformName caseOf:		{['Win32'] -> [String crlf]}		otherwise: [String lf]! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!obtainPackageDir: aDefinition	"I'm assuming first category is actually the package"		^ aDefinition categories first! !!TonelWriter methodsFor: 'private' stamp: 'edc 10/11/2020 07:18'!packageOf: aClass	^ aClass category! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!selectorIsComplete: keywords in: aString	keywords inject: 1 into: [ :start :key | | startOfKey | 		startOfKey := aString 			findString: key 			startingAt: start 			caseSensitive: true.		startOfKey = 0 ifTrue: [ ^ false ].		startOfKey + key size ].	^ true! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!skipComment: aStream	"I assume I'm on top of the begining of a comment"	aStream skip: 1.	[ aStream atEnd not 		and: [ aStream next ~= $" or: [ aStream peek = $" ] ] ]	whileTrue.	! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!skipSeparators: aStream	[ aStream peek isSeparator ]	whileTrue: [ aStream skip: 1 ]. ! !!TonelWriter methodsFor: 'private' stamp: 'jr 12/9/2018 19:43'!splitMethodSource: aMethodDefinition into: aBlock	| keywords source declaration |		keywords := aMethodDefinition selector keywords.	source := aMethodDefinition source readStream.	"Skip spaces"	(source peek isSeparator) ifTrue: [ self skipSeparators: source ].	"Skip comments"	(source peek = $") ifTrue: [ self skipComment: source ]. 	"Parse declaration"	declaration := String new writeStream.	[ (self selectorIsComplete: keywords in: declaration originalContents) not 		or: [ ':+-/\*~<>=@,%|&?!!' includes: declaration contents withoutTrailingBlanks last ] ]	whileTrue: [ 		"stop infinite loop if no match was found"		source atEnd ifTrue: [ TonelWriteError signal: 'Cannot find selector in source for ', aMethodDefinition asString ].		"get separators"		[ source atEnd not and: [ source peek isSeparator ] ]			whileTrue: [ declaration nextPut: source next ].		"take next word"		[ source atEnd not and: [ source peek isSeparator not ] ]			whileTrue: [ declaration nextPut: source next ] ].	aBlock 		value: (declaration contents withoutLeadingBlanks withLineEndings: self newLine)		value: (source upToEnd withLineEndings: self newLine)! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!toSTON: anObject	^ String streamContents: [ :outStream | 		(TonelSTONWriter on: outStream) 			newLine: self newLine;			nextPut: anObject ]! !!TonelWriter methodsFor: 'private' stamp: '12/9/2018 20:41:24'!typeOf: aClassDefinition	(self isClass: aClassDefinition) ifTrue: [ ^ self class classLabel ].	(self isTrait: aClassDefinition) ifTrue: [ ^ self class traitLabel ].	TonelShouldIgnore signal! !!TonelWriter methodsFor: 'private definitions' stamp: '12/9/2018 20:41:24'!commentOf: aClassDefinition	^ (aClassDefinition comment 		copyReplaceAll: '"' 		with: '""')		withLineEndings: self newLine! !!TonelWriter methodsFor: 'private definitions' stamp: '12/9/2018 20:41:24'!methodDefinitionOf: aMethodDefinition	^ self toSTON: (OrderedDictionary new 		at: #category put: aMethodDefinition category; 		yourself)		! !!TonelWriter methodsFor: 'private definitions' stamp: '12/9/2018 20:41:24'!typeClassDefinitionOf: aClassDefinition	| definition |		definition := OrderedDictionary new 		at: #name put: aClassDefinition className; 		at: #superclass put: aClassDefinition superclassName;		yourself.	aClassDefinition type = #normal ifFalse: [ 		definition at: #type put: aClassDefinition type ].		aClassDefinition hasTraitComposition ifTrue: [ 		definition at: #traits put: aClassDefinition traitCompositionString ].		aClassDefinition hasClassTraitComposition ifTrue: [ 		definition at: #classTraits put: aClassDefinition classTraitCompositionString ].		(aClassDefinition variables select: #isInstanceVariable thenCollect: #name)		ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].	(aClassDefinition variables select: #isClassVariable thenCollect: #name)		ifNotEmpty: [ :vars | definition at: #classVars put: vars asArray ].			(aClassDefinition variables select: #isPoolImport thenCollect: #name)		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].			(aClassDefinition variables select: #isClassInstanceVariable thenCollect: #name)		ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ].	definition 				at: #category put: aClassDefinition category.		^ self toSTON: definition! !!TonelWriter methodsFor: 'private definitions' stamp: '12/9/2018 20:41:24'!typeDefinitionOf: aClassDefinition	(self isTrait: aClassDefinition) 		ifTrue: [ ^ self typeTraitDefinitionOf: aClassDefinition ].	^ self typeClassDefinitionOf: aClassDefinition! !!TonelWriter methodsFor: 'private definitions' stamp: '12/9/2018 20:41:24'!typeTraitDefinitionOf: aClassDefinition	| definition |		definition := OrderedDictionary new 		at: #name put: aClassDefinition className; 		yourself.	aClassDefinition variables isEmptyOrNil ifFalse: [ 		(aClassDefinition variables select: #isInstanceVariable thenCollect: #name)			ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].		(aClassDefinition variables select: #isClassInstanceVariable thenCollect: #name)			ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ] ].	aClassDefinition hasTraitComposition ifTrue: [ 		definition					at: #traits 			put: aClassDefinition traitCompositionString ].			aClassDefinition hasClassTraitComposition ifTrue: [ 		definition					at: #classTraits 			put: aClassDefinition classTraitCompositionString ].		definition at: #category put: aClassDefinition category.			^ self toSTON: definition! !!TonelWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!directoryReference	^ directoryReference! !!TonelWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!directoryReference: aFileReference	directoryReference := aFileReference! !!TonelWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!fileUtils	^ TonelFileUtils current! !!TonelWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!packageDir	^ packageDir 		ifNotNil: [ self fileUtils directoryFromPath: packageDir relativeTo: self directoryReference ]		ifNil: [ self directoryReference  ]! !!TonelWriter methodsFor: 'accessing' stamp: 'jr 3/16/2019 23:19'!packageName: aString	packageDir := aString.! !!TonelWriter methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!snapshot: anObject	snapshot := anObject! !!TonelWriter methodsFor: 'writing' stamp: 'jr 12/13/2018 00:00'!exportClass: aClass on: aStream	snapshot := (MCVersion package: (MCPackage named: (self packageOf: aClass) name)) snapshot.	self writeClass: aClass asClassDefinition on: aStream.	^ aStream! !!TonelWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!writeClass: aClassDefinition	[ self fileUtils writeStreamFor: (self fileNameFor: aClassDefinition) in: self packageDir do: [ :aStream | self writeClass: aClassDefinition on: aStream ] ]		on: TonelShouldIgnore		do: [ :e | self logCr: 'ignoring: ' , aClassDefinition asString ]! !!TonelWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!writeClass: aClassDefinition on: aStream	[ self writeClassDefinition: aClassDefinition on: aStream.	self writeClassSideMethodDefinitions: aClassDefinition on: aStream.	self writeInstanceSideMethodDefinitions: aClassDefinition on: aStream ]		on: TonelShouldIgnore		do: [ :e | self logCr: 'ignoring: ' , aClassDefinition asString ]! !!TonelWriter methodsFor: 'writing' stamp: 'TonelWriterTest 12/12/2018 22:56'!writeExtensionMethods: methods className: className	| nl |	nl := self newLine.	self fileUtils 		writeStreamFor: (className, '.extension.st') 		in: self packageDir 		do: [ :s |			s nextPutAll: 'Extension '; nextPutAll: (self toSTON: ({ #name -> className } as: Dictionary)); nextPutAll: nl.			(methods sorted: [ :a :b | a selector < b selector ])				do: [ :each | self writeMethodDefinition: each on: s ] ]! !!TonelWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!writeMethodExtensions	| classesAndMethods |	classesAndMethods := Dictionary new.	snapshot definitions 		select: [ :each | each isMethodDefinition and: [ each isExtensionMethod ] ]		thenDo: [ :each | 			(classesAndMethods 				at: each className				ifAbsentPut: [ Set new ])				add: each ].	classesAndMethods keysAndValuesDo: [ :className :methods | 		self 			writeExtensionMethods: methods 			className: className ]			! !!TonelWriter methodsFor: 'writing' stamp: 'jr 3/16/2019 23:04'!writePackage: aDefinition	packageDir ifNil: [packageDir := self obtainPackageDir: aDefinition].	self flag: #todo. "this is lame... removing and rewriting full package needs to be rethink :)"	(self fileUtils directoryExists: self packageDir) ifTrue: [ 		self fileUtils deleteAll: self packageDir ].  	self fileUtils ensureDirectoryExists: self packageDir.	self fileUtils 		writeStreamFor: 'package.st' 		in: self packageDir 		do: [ :s | 			s 				nextPutAll: 'Package ';				nextPutAll: (self toSTON: ({ #name ->  packageDir asSymbol } as: Dictionary));				nextPutAll: self newLine ]! !!TonelWriter methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!writeSnapshot: aSnapshot	snapshot := aSnapshot.		"ensure package dirs exists. 	 It has to be just one but well..."	self writePackage: (snapshot definitions 		detect: #isOrganizationDefinition		ifFound: [ :each | each ]		ifNone: [ self createDefaultOrganizationFrom: (snapshot definitions detect: #isClassDefinition) ]).	"now export classes"	(snapshot definitions 		select: #isClassDefinition)		do: [ :each | self writeClass: each ].	"... and method extensions"	self writeMethodExtensions! !!TonelWriter methodsFor: 'writing' stamp: 'jr 3/16/2019 22:58'!writeVersion: aVersion	packageDir := aVersion package name.	self writeSnapshot: aVersion snapshot! !!TonelWriter methodsFor: 'private testing' stamp: '12/9/2018 20:41:24'!isClass: aClassDefinition	^ aClassDefinition class = MCClassDefinition! !!TonelWriter methodsFor: 'private testing' stamp: '12/9/2018 20:41:24'!isTrait: aClassDefinition	^ aClassDefinition class = MCTraitDefinition ! !!TonelWriter methodsFor: 'private writing' stamp: 'jr 12/9/2018 19:43'!writeClassDefinition: aClassDefinition on: aStream	| nl |	nl := self newLine.		aClassDefinition hasComment 		ifTrue: [ 			aStream 				nextPutAll: '"'; nextPutAll: nl;				nextPutAll: (self commentOf: aClassDefinition); nextPutAll: nl;				nextPutAll: '"'; nextPutAll: nl ].	aStream		nextPutAll: (self typeOf: aClassDefinition);		nextPutAll: ' '; nextPutAll: (self typeDefinitionOf: aClassDefinition ); nextPutAll: nl! !!TonelWriter methodsFor: 'private writing' stamp: '12/9/2018 20:41:24'!writeClassSideMethodDefinitions: aClassDefinition on: aStream	((snapshot definitions 		select: [ :each | 			each isMethodDefinition 			and: [ each className = aClassDefinition className			and: [ each classIsMeta ] ] ])		sorted: [ :a :b | a selector < b selector ])		do: [ :each | 			self writeMethodDefinition: each parent: aClassDefinition on: aStream ]! !!TonelWriter methodsFor: 'private writing' stamp: '12/9/2018 20:41:24'!writeInstanceSideMethodDefinitions: aClassDefinition on: aStream	((snapshot definitions 		select: [ :each | 			each isMethodDefinition 			and: [ each className = aClassDefinition className			and: [ each classIsMeta not ] ] ])		sorted: [ :a :b | a selector < b selector ])		do: [ :each | 			self writeMethodDefinition: each parent: aClassDefinition on: aStream ]		! !!TonelWriter methodsFor: 'private writing' stamp: '12/9/2018 20:41:24'!writeMethodDefinition: aMethodDefinition on: aStream	^ self 		writeMethodDefinition: aMethodDefinition 		parent: nil 		on: aStream! !!TonelWriter methodsFor: 'private writing' stamp: 'jr 12/9/2018 19:43'!writeMethodDefinition: aMethodDefinition parent: aClassDefinition on: aStream	| nl |		nl := self newLine.	self 		splitMethodSource: aMethodDefinition 		into: [ :methodDeclaration :methodBody | | fullClassName |			fullClassName := self classNameFor: aMethodDefinition parent: aClassDefinition.			aStream 				nextPutAll: nl;				nextPutAll: (self methodDefinitionOf: aMethodDefinition); nextPutAll: nl;				nextPutAll: fullClassName; nextPutAll: ' >> '; nextPutAll: methodDeclaration;				nextPutAll: ' ['; nextPutAll: methodBody; nextPutAll: nl; nextPutAll: ']'; nextPutAll: nl]! !!TonelWriter class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!classLabel	^ 'Class'! !!TonelWriter class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!extensionLabel	^ 'Extension'! !!TonelWriter class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!readerClass	^ TonelReader! !!TonelWriter class methodsFor: 'accessing' stamp: '12/9/2018 20:41:24'!traitLabel	^ 'Trait'! !!TonelWriter class methodsFor: 'writing - class' stamp: '12/9/2018 20:41:24'!exportClass: aClass on: aStream	"I take a class and a stream as parameter and export the class in Tonel format into the stream."		^ self new exportClass: aClass on: aStream! !!TonelWriter class methodsFor: 'writing - class' stamp: '12/9/2018 20:41:24'!sourceCodeOf: aClass	"I take as a parameter a class and I return it's tonel export as a String."		^ String streamContents: [ :aStream | self new exportClass: aClass on: aStream ]! !!TonelWriter class methodsFor: 'writing' stamp: '12/9/2018 20:41:24'!fileOut: aVersion on: aStream	(self on: aStream) writeVersion: aVersion	! !!TonelWriter class methodsFor: 'instance creation' stamp: '12/9/2018 20:41:24'!on: directoryReference	^ self new		directoryReference: directoryReference;		yourself! !!UndefinedObject methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:27'!stonContainSubObjects 	^ false! !!UndefinedObject methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 15:54'!stonOn: stonWriter	stonWriter writeNull! !STONWriter initialize!Dictionary subclass: #OrderedDictionary	instanceVariableNames: 'order'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!