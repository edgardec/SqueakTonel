"
FORTRANNumberParser is able to parse ASCII representation of numbers generated by FORTRAN programs.

Possible syntax:
	digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
	sign =  '+' | '-';
	integer = [sign] digit{digit} ;
	float = [sign] [digit{digit}] ['.'] digit{digit} [('E' | 'D' ) [sign] digit{digit} ] ;
	number = integer | float ;
	
Examples:
	124
	+124
	-124
	1.0
	1.
	.23
	1E+5
	1.0E-3
	.1E-22
	3.01D+55

Not accepted: exponent letter is sometimes omitted for double precision with 3 digits exponent...
	1.001-123

Not accepted: complex numbers into parentheses
	(1.0 , 3.11)

"
Class {
	#name : #FORTRANNumberParser,
	#superclass : #NumberParser,
	#category : #'Kernel-Numbers'
}

{ #category : #accessing }
FORTRANNumberParser >> allowPlusSign [
	^true
]

{ #category : #accessing }
FORTRANNumberParser >> exponentLetters [
	"answer the list of possible exponents for Numbers.
	Note: this parser will not honour precision attached to the exponent.
	different exponent do not lead to different precisions.
	only IEEE 754 double precision floating point numbers will be created"

	^'ED'
]

{ #category : #'parsing-public' }
FORTRANNumberParser >> nextFloat [
	^self nextNumber asFloat
]

{ #category : #'parsing-public' }
FORTRANNumberParser >> nextNumber [
	"main method for reading a number with FORTRAN syntax.
	This one can read Real and Integer (not complex)"

	| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa value numberOfTrailingZeroInFractionPart noInt |
	base := 10.
	(self nextMatchAll: 'NaN') ifTrue: [^Float nan].
	neg := self peekSignIsMinus.
	(self nextMatchAll: 'Infinity') 
		ifTrue: [^neg ifTrue: [Float negativeInfinity] ifFalse: [Float infinity]].
	(noInt := sourceStream peekFor: $.) 
		ifTrue: 
			[integerPart := 0.
			numberOfTrailingZeroInIntegerPart := 0]
		ifFalse: 
			[integerPart := self nextUnsignedIntegerBase: base.
			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].
	(noInt or: [sourceStream peekFor: $.]) 
		ifTrue: 
			[fractionPart := self nextUnsignedIntegerBase: base ifFail: [nil].
			fractionPart isNil 
				ifTrue: 
					[noInt 
						ifTrue: 
							["no interger part, no fraction part..."
							self expected: 'a digit 0 to 9'.
							^nil].
					fractionPart := 0]
				ifFalse: 
					[numberOfNonZeroFractionDigits := lastNonZero.
					numberOfTrailingZeroInFractionPart := nDigits - lastNonZero].
			self readExponent]
		ifFalse: 
			[self readExponent ifFalse: [^neg ifTrue: [integerPart negated] ifFalse: [integerPart]].
			fractionPart := 0].
	fractionPart isZero 
		ifTrue: 
			[mantissa := integerPart // (base raisedTo: numberOfTrailingZeroInIntegerPart).
			exponent := exponent + numberOfTrailingZeroInIntegerPart]
		ifFalse: 
			[mantissa := integerPart * (base raisedTo: numberOfNonZeroFractionDigits) 
						+ (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).
			exponent := exponent - numberOfNonZeroFractionDigits].
	value := self 
				makeFloatFromMantissa: mantissa
				exponent: exponent
				base: base.
	^neg ifTrue: [value isZero ifTrue: [Float negativeZero] ifFalse: [value negated]] ifFalse: [value]
]
