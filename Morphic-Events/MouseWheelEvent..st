Class {
	#name : #MouseWheelEvent,
	#superclass : #MouseEvent,
	#instVars : [
		'delta',
		'direction'
	],
	#category : #'Morphic-Events'
}

{ #category : #utility }
MouseWheelEvent class >> convertScrollUnits: scrollUnits intoScrollDelta: scrollDeltaPerMouseWheelNotch [
	"Convert the scrolling units provided by the VM into scrolling delta (increment) used by Morph.
	The morph knows how many scroll delta it wants per single wheel notch.
	I know how many scrolling units is generated by a single wheel notch."
	
	^scrollUnits abs * scrollDeltaPerMouseWheelNotch // self scrollUnitsPerMouseWheelNotch max: 1
]

{ #category : #constants }
MouseWheelEvent class >> minimalScrollUnitsPerEvent [
	"Answer how many scroll units a single mouse wheel event can generate.
	This reflects a value hardcoded in the VM.
	The VM aggregate wheel events until this threshold is reached."
	
	^20
]

{ #category : #constants }
MouseWheelEvent class >> scrollUnitsPerMouseWheelNotch [
	"Answer how many scroll units a single mouse wheel notch does generate.
	This reflects a value hardcoded in the VM.
	The value is chosen high enough so as to enable:
	- smoother scrolling on notch-less devices.
	- while preserving Integer arithmetic
	Interpretation (scaling) of scrolling units is left to the client morphs.
	Typically, 120 units (1 notch) represents 3 lines of text."
	
	^120
]

{ #category : #accessing }
MouseWheelEvent >> horizontalScrollDelta: scrollDeltaPerMouseWheelNotch [
	"Convert scrolling units into unsigned scrolling increment.
	The morph knows how many scroll delta it wants per single wheel notch.
	Note that returned increment value is always positive, regardless of direction."
	^self class convertScrollUnits: delta x intoScrollDelta: scrollDeltaPerMouseWheelNotch
]

{ #category : #initialization }
MouseWheelEvent >> initialize [

	super initialize.
	direction := 2r0000.
	delta := 0@0.
]

{ #category : #testing }
MouseWheelEvent >> isMouseWheel [
	^ true
]

{ #category : #testing }
MouseWheelEvent >> isWheelDown [
	^ direction anyMask: 2r0100
]

{ #category : #testing }
MouseWheelEvent >> isWheelLeft [
	^ direction anyMask: 2r0010
]

{ #category : #testing }
MouseWheelEvent >> isWheelRight [
	^ direction anyMask: 2r0001
]

{ #category : #testing }
MouseWheelEvent >> isWheelUp [
	^ direction anyMask: 2r1000
]

{ #category : #printing }
MouseWheelEvent >> printOn: aStream [

	aStream nextPut: $[.
	aStream nextPutAll: self cursorPoint printString; space.
	aStream nextPutAll: type; space.
	aStream nextPutAll: self wheelString.
	aStream nextPutAll: self wheelDelta printString; space.
	aStream nextPutAll: self modifierString.
	aStream nextPutAll: self buttonString.
	aStream nextPutAll: timeStamp printString; space.
	aStream nextPut: $].
]

{ #category : #dispatching }
MouseWheelEvent >> sentTo: anObject [
	"Dispatch the receiver into anObject"
	type == #mouseWheel ifTrue: [^ anObject handleMouseWheel: self].
	^ super sentTo: anObject
]

{ #category : #initialization }
MouseWheelEvent >> setDirection [
	delta x > 0 ifTrue: [self setWheelRight].
	delta x < 0 ifTrue: [self setWheelLeft].

	delta y > 0 ifTrue: [self setWheelUp].
	delta y < 0 ifTrue: [self setWheelDown].
]

{ #category : #private }
MouseWheelEvent >> setType: evtType position: evtPos delta: evtDelta buttons: evtButtons hand: evtHand stamp: stamp [
	type := evtType.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	direction := 2r0000.
	delta := evtDelta.
	timeStamp := stamp.
	self setDirection
]

{ #category : #private }
MouseWheelEvent >> setType: evtType position: evtPos delta: evtDelta direction: dirFlags buttons: evtButtons hand: evtHand stamp: stamp [
	type := evtType.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	direction := dirFlags.
	delta := evtDelta.
	timeStamp := stamp.
]

{ #category : #initialization }
MouseWheelEvent >> setWheelDown [

	direction := direction bitOr: 2r0100.
]

{ #category : #initialization }
MouseWheelEvent >> setWheelLeft [

	direction := direction bitOr: 2r0010.
]

{ #category : #initialization }
MouseWheelEvent >> setWheelRight [

	direction := direction bitOr: 2r0001.
]

{ #category : #initialization }
MouseWheelEvent >> setWheelUp [

	direction := direction bitOr: 2r1000.
]

{ #category : #printing }
MouseWheelEvent >> storeOn: aStream [
	"Note: We generate the same array as provided by the VM. BUT we are a subclass of MouseEvent now even if we cannot store the position right now. This is awkward. But we still store the position and the wheel delta. *sign*"
	
	super storeOn: aStream.
	aStream space.
	delta x storeOn: aStream.
	aStream space.
	delta y storeOn: aStream.
	aStream space.
	direction storeOn: aStream.

]

{ #category : #initialization }
MouseWheelEvent >> type: eventType readFrom: aStream [

	| deltaX deltaY |
	super type: eventType readFrom: aStream.
	aStream skip: 1.
	deltaX := Integer readFrom: aStream.
	aStream skip: 1.
	deltaY := Integer readFrom: aStream.
	aStream skip: 1.
	direction := Integer readFrom: aStream.
	delta := deltaX @ deltaY.

]

{ #category : #accessing }
MouseWheelEvent >> verticalScrollDelta: scrollDeltaPerMouseWheelNotch [
	"Convert scrolling units into unsigned scrolling increment.
	The morph knows how many scroll delta it wants per single wheel notch.
	Note that returned increment value is always positive, regardless of direction."
	^self class convertScrollUnits: delta y intoScrollDelta: scrollDeltaPerMouseWheelNotch
]

{ #category : #accessing }
MouseWheelEvent >> wheelDelta [

	^ delta
]

{ #category : #printing }
MouseWheelEvent >> wheelString [
	"Return a string identifying the wheel state"
	
	^ String streamContents: [:stream |
		self isWheelUp ifTrue: [stream nextPutAll: 'up '].
		self isWheelDown ifTrue: [stream nextPutAll: 'down '].
		self isWheelLeft ifTrue: [stream nextPutAll: 'left '].
		self isWheelRight ifTrue: [stream nextPutAll: 'right ']]
]
