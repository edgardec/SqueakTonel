Class {
	#name : #KedamaAttributeEvaluator,
	#superclass : #Object,
	#instVars : [
		'symbolClasses',
		'declaredAttributes',
		'attributes',
		'intrinsicSemanticRules',
		'semanticRules',
		'parseTree',
		'attributedTree',
		'receiver',
		'dependencies',
		'references'
	],
	#classVars : [
		'Debug',
		'Default'
	],
	#category : #'Etoys-Squeakland-Tweak-Kedama-ParseTreeTransformer'
}

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> clearGeneratedMethodsFrom: rootClass [
"
	self clearGeneratedMethodsFrom: ParseNode
"
	(rootClass allSubclasses copyWith: rootClass) do: [:cls |
		#('*Autogenerated-Kedama' '*Autogenerated-Kedama-accessing') do: [:cat |
			(cls organization listAtCategoryNamed: cat) do: [:sel |
				cls removeSelectorSilently: sel.
			]
		].
	].
	"(ParseNode organization listAtCategoryNamed: 'accessing') do: [:sel |
		ParseNode removeSelectorSilently: sel
	].
"

]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> clearInstVarFrom: rootClass except: aCollection [
"
	self clearInstVarFrom: ParseNode except: #('comment' 'pc').
"
	| instVars |
	instVars := rootClass instVarNames select: [:var |
		(aCollection includes: var) not.
	].
	rootClass removeInstVarNames: instVars. 
	
	(rootClass organization listAtCategoryNamed: 'accessing') do: [:sel |
		rootClass removeSelectorSilently: sel
	].


]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> default [

	^ Default

]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> setDefault: anObject [

	Default := anObject.

]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> setDefaultEvaluator [
"
	self setDefaultEvaluator
"
"	| evaluator |
	evaluator := KedamaAttributeEvaluator new.
	evaluator defineSyntaxFrom: KedamaAttributeEvaluator tweakTileParseNodes.
	evaluator readDefinitionsFrom: KedamaTurtleDefinition.
	KedamaAttributeEvaluator setDefault: evaluator.
	evaluator compileEvaluator.
"
]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> squeakParseNodes [

	^ {
			{"Main parse node definitions"
				{ParseNode.			#().					false}.
				{AssignmentNode. 	#(variable value).	false}.
				{BlockNode.		#(arguments statements).false}.
				{BraceNode.		#(elements).			false}.
				{CascadeNode.		#(receiver messages). false}.
				{CommentNode.		#(). true}.
				{LeafNode.		#(key).	true}.
				{LiteralNode.		#(). true}.
				{SelectorNode.		#(). true}.
				{VariableNode.		#(name). true}.
				{LiteralVariableNode.	#(). true}.
				{TempVariableNode.	#(). true}.
				{MessageNode.		#(receiver selector arguments). false}.
				{MessageAsTempNode.	#(). false}.
				{MethodNode.		#(selectorOrFalse arguments block). false}.
				{MethodTempsNode.	#(). false}.
				{ReturnNode.		#(expr). false}
			}.
			{"Aliases for parse nodes that should use the same attributes as another"
				SpecialSelectorNode -> SelectorNode.
			}
}
]

{ #category : #'as yet unclassified' }
KedamaAttributeEvaluator class >> tweakTileParseNodes [

	^ {
"	{CTilePlayer.			#().					false}.
	{CMessageLikeTile.	#().						false}.
	{CAssignmentTile. 	#(property expression operator).	false}.
	{CBlockTile. 			#(arguments temporaries statements).	false}.
	{CMessageTile.		#(arguments receiver selector).	false}.
	{COperatorTile.		#(arguments receiver selector).	false}.
	{CPropertyTile.		#(property receiver). 	false}.
	{CSequenceTile.		#(arguments temporaries statements). false}.
	{CScriptorTile.		#(arguments temporaries statements).	false}.
	{CSeparatorTile.		#(). true}.
	{CValueTile.			#(). true}.
	{CLeafVariableTile.			#(). true}.
	{CVariableTile.		#(expression). false}."
}
]

{ #category : #private }
KedamaAttributeEvaluator >> addGraphEdgesAt: parseNode andParent: parentNode [

	| deps occurrences rule |
	occurrences := parseNode xxxOccurences.
	occurrences do: [:oc |
		rule := self selectRuleFor: oc at: parseNode andParent: parentNode.
		rule ifNil: [self error: 'no applicable rule found'].
		oc selectedRule: rule.
		rule inputSpecs size = 0 ifTrue: [oc outTime: 0].
		"oc attributeName = #isTopStatement ifTrue: [self halt]."
		rule inputSpecs do: [:inputSpec |
			deps := self addGraphEdgesAt: parseNode andParent: parentNode fromRule: rule forInputSpec: inputSpec.
			deps size > 0 ifTrue: [
				self addToDependencies: deps.
				oc inputSizeAt: (rule inputSpecs indexOf: inputSpec) put: ((inputSpec type == #allChildrenSynth) ifTrue: [Array with: deps size] ifFalse: [1]).
			].
		].
	].
	parseNode isLeaf ifFalse: [
		parseNode getAllChildren do: [:child |
			self addGraphEdgesAt: child andParent: parseNode.
		].
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> addGraphEdgesAt: parseNode andParent: parentNode fromRule: rule forInputSpec: inputSpec [

	| type |
	type := inputSpec type.

	type == #intrinsic ifTrue: [
		^ #().
	].
	type == #myInh ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forMyInhRule: rule inputSpec: inputSpec.
	].
	type == #mySynth ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forMySynthRule: rule inputSpec: inputSpec.
	].
	type == #parentInh ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forParentInhRule: rule inputSpec: inputSpec.
	].
	type == #allChildrenSynth ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forAllChildSynthRule: rule inputSpec: inputSpec.
	].
	type == #parentInhFirstChild ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forFirstChildInhRule: rule inputSpec: inputSpec.
	].
	type == #elderSiblingSynth ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forElderSiblingInhRule: rule inputSpec: inputSpec.
	].
	type == #lastChildSynth ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forLastChildSynthRule: rule inputSpec: inputSpec.
	].
	type == #parentSynth ifTrue: [
		^ self makeGraphEdgesAt: parseNode andParent: parentNode forParentSynthRule: rule inputSpec: inputSpec.
	].



]

{ #category : #actions }
KedamaAttributeEvaluator >> addGraphEdgesRoot [

	dependencies := IdentityDictionary new.
	self addGraphEdgesAt: parseTree andParent: nil.

]

{ #category : #private }
KedamaAttributeEvaluator >> addRule: rule forAttribute: anAttribute [

	(intrinsicSemanticRules at: anAttribute grammarClass) addFirst: rule.
	(anAttribute grammarClass allSubclasses copyWith: anAttribute grammarClass) do: [:c |
		(symbolClasses includes: c) ifTrue: [
			(semanticRules at: c) addFirst: rule.
		].
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> addToDependencies: deps [

	| src dst list |
	deps do: [:pair |
		src := ((pair at: 1) at: 2) perform: ((pair at: 1) at: 1).
		dst := ((pair at: 2) at: 2) perform: ((pair at: 2) at: 1).
		list := dependencies at: src ifAbsentPut: [WriteStream on: (Array new: 8)].
		list nextPut: dst.
		dst addSource: src.
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> attributeDefinitionsOf: grammarClass [

	^ attributes at: grammarClass ifAbsent: [#()].

]

{ #category : #accessing }
KedamaAttributeEvaluator >> attributedTree [

	^ attributedTree.

]

{ #category : #actions }
KedamaAttributeEvaluator >> clearReferences [

	parseTree := nil.
	attributedTree := nil.
	receiver := nil..
	dependencies := nil.

]

{ #category : #actions }
KedamaAttributeEvaluator >> compileEvaluator [

	| meth |
	semanticRules associationsDo: [:assoc |
		assoc value do: [:rule |
			meth := rule ruleText.
			Debug == true ifTrue: [
				Transcript show: assoc key name; cr; show: meth; cr.
			].
			assoc key compileSilently: meth classified: '*Autogenerated-Kedama'.
		].
	].

]

{ #category : #accessing }
KedamaAttributeEvaluator >> debug: aBoolean [

	Debug := aBoolean

]

{ #category : #'input definitions' }
KedamaAttributeEvaluator >> defineAttributeNamed: attrName at: grammarClass type: inhOrSynth [

	| attr |

	grammarClass withAllSubclassesDo: [:c |
		attr := ParseNodeAttribute new.
		attr grammarClass: c.
		attr attributeName: attrName.
		attr type: inhOrSynth.
		(symbolClasses includes: c) ifTrue: [
			(attributes at: c) at: attrName asSymbol put: attr.
		].
	].
	declaredAttributes at: grammarClass ifAbsentPut: [OrderedCollection new].
	(declaredAttributes at: grammarClass) add: attrName.

]

{ #category : #'input definitions' }
KedamaAttributeEvaluator >> defineSemanticRuleFor: anAttribute rule: aString selector: selector uses: inputSpecs [

	| rule  |
	inputSpecs do: [:spec |
		(#(parentInh parentSynth parentInhFirstChild elderSiblingSynth lastChildSynth mySynth myInh allChildrenSynth intrinsic) includes: spec type) ifFalse: [^ self error: 'wrong input specification'].
	].
	rule := AttributeSemanticRule new.
	rule output: anAttribute.
	rule inputSpecs: inputSpecs.
	rule ruleText: aString.

"
	selector := String streamContents: [:strm |
		strm nextPutAll: anAttribute attributeName.
		inputSpecs do: [:in |
			strm nextPutAll: in uniqueName.
			strm nextPutAll: ':'.
		].
	].
"

	rule selector: selector asSymbol.
	(anAttribute grammarClass allSubclasses copyWith: anAttribute grammarClass) do: [:c |
		(symbolClasses includes: c) ifTrue: [
			((attributes at: c) at: anAttribute attributeName) addRule: rule.
		].
	].

	self addRule: rule forAttribute: anAttribute.

]

{ #category : #'input definitions' }
KedamaAttributeEvaluator >> defineSyntaxFrom: list [

	^ self defineSyntaxFrom: list first withAliases: list second
]

{ #category : #'input definitions' }
KedamaAttributeEvaluator >> defineSyntaxFrom: list withAliases: anotherList [

	symbolClasses := OrderedCollection new.
	list do: [:triple |
		symbolClasses add: triple first.
	].

	symbolClasses := symbolClasses asArray.
	attributes := IdentityDictionary new.
	semanticRules := IdentityDictionary new.
	intrinsicSemanticRules := IdentityDictionary new.
	symbolClasses do: [:t |
		attributes at: t put: IdentityDictionary new.
		semanticRules at: t put: OrderedCollection new.
		intrinsicSemanticRules at: t put: OrderedCollection new.
	].

	anotherList do: [:assoc |
		attributes at: assoc key put: (attributes at: assoc value).
	].
]

{ #category : #actions }
KedamaAttributeEvaluator >> evaluateAllOccurence [

	self sortDependencies do: [:x | self evaluateOccurence: x].

]

{ #category : #private }
KedamaAttributeEvaluator >> evaluateOccurence: occurence [

	"pick the attribute from the occurence at parseNode."
	"check the dependency for that occurence."
	"if they are not evaluated, recursively call itself with new arguments."
	"if all the values are evaluated, #perform: the registered method with these values."

	| ret n args realArgs |
	n := occurence node.
	args := ReadStream on: (occurence dependencies collect: [:oc | oc value]).
	realArgs := Array new: 0.
	occurence inputSizes do: [:s |
		s isCollection ifTrue: [
			realArgs := realArgs copyWith: (args next: (s at: 1)).
		] ifFalse: [
			realArgs := realArgs copyWith: args next.
		].
	].
			
	(n = parseTree and: [occurence selectedRule selector = #rcvr]) ifTrue: [
		ret := receiver
	] ifFalse: [
		ret := n perform: occurence selectedRule selector withArguments: realArgs.
	].
	Debug == true ifTrue: [
		Transcript show: n printString, ' ', occurence selectedRule selector, ' ', args printString, ' ', realArgs printString, ' ', ret printString; cr.
	].
	occurence value: ret.

]

{ #category : #private }
KedamaAttributeEvaluator >> generateInstVarAndAccessor: attrName forGrammarClass: grammarClass [

	| newMessage |
	newMessage := attrName, '
	"Answer the value of ', attrName, '"

	^ (KedamaEvaluatorNodeState stateFor: self at: #', attrName, ') value'.
		grammarClass compileSilently: newMessage classified: '*Autogenerated-Kedama-accessing' notifying: nil.

		newMessage := 'raw', attrName, '
	"Answer the value of ', attrName, '"

	^ KedamaEvaluatorNodeState stateFor: self at: #', attrName.
		grammarClass compileSilently: newMessage classified: '*Autogenerated-Kedama-accessing' notifying: nil.

		newMessage := attrName, ':', ' anObject
	"Set the value of ', attrName, '"

	KedamaEvaluatorNodeState stateFor: self at: #', attrName, ' put: anObject'.
		grammarClass compileSilently: newMessage classified: '*Autogenerated-Kedama-accessing' notifying: nil

]

{ #category : #private }
KedamaAttributeEvaluator >> generateInstVarAndAccessors [

	declaredAttributes keysDo: [:cls |
		self generateInstVarAndAccessorsForGrammarClass: cls
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> generateInstVarAndAccessorsForGrammarClass: grammarClass [

	| attrs |
	attrs := declaredAttributes at: grammarClass ifAbsent: [#()].
	grammarClass = ParseNode ifTrue: [attrs := attrs copyWith: #xxxOccurences].
	"tfel: We no longer add inst vars to the class, to allow clean loading and unloading of Etoys. We instead keep the instance specific
	state in a weak dictionary on a special class singleton"
	attrs do: [:attrName |
		KedamaEvaluatorNodeState dictionary at: attrName put: WeakIdentityKeyDictionary new.
		self generateInstVarAndAccessor: attrName forGrammarClass: grammarClass
	].

]

{ #category : #'initialize-release' }
KedamaAttributeEvaluator >> initialize [

	declaredAttributes := Dictionary new.
	references := IdentityDictionary new.

]

{ #category : #private }
KedamaAttributeEvaluator >> isApplicable: rule at: parseNode andParent: parentNode [

	rule inputSpecs size = 0 ifTrue: [^ true].
	rule inputSpecs collect: [:spec |
		(self matchSpec: spec at: parseNode andParent: parentNode) ifFalse: [^ false].
	].
	^ true.

]

{ #category : #actions }
KedamaAttributeEvaluator >> makeAttributedTreeWith: aParseTree forReceiver: anObject [

	parseTree := aParseTree normalize.
	attributedTree := AttributeVisitor new.
	attributedTree newWith: parseTree for: self.
	receiver := anObject.

]

{ #category : #private }
KedamaAttributeEvaluator >> makeDependencyEdgeFromAttribute: fromAttr at: fromNode toAttribute: toAttr at: toNode [

	^ Array with: ((Array with: fromAttr with: fromNode))
				with: ((Array with: toAttr with: toNode)).
"
	^ Array with: (attributedTree attribute: fromAttr at: fromNode)
				with: (attributedTree attribute: toAttr at: toNode).

"
]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forAllChildSynthRule: semanticRule inputSpec: inputSpec [

	| outName inName ret |

	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parseNode isLeaf ifTrue: [
		^ #().
	].

	ret := WriteStream on: (Array new: 4).
	parseNode getAllChildren do: [:childNode |
		ret nextPut: (Array with: (Array with: inName with: childNode)
							with: (Array with: outName with: parseNode)).
	].
	^ ret contents.

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forElderSiblingInhRule: semanticRule inputSpec: inputSpec [

	| inName outName elder |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parentNode ifNil: [
		^ #().
	].

	(parentNode isFirstChild: parseNode) ifTrue: [
		^ #().
	] ifFalse: [
		elder := parentNode getElderSiblingOf: parseNode.
		^ Array with: (self makeDependencyEdgeFromAttribute: inName at: elder toAttribute: outName at: parseNode).
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forFirstChildInhRule: semanticRule inputSpec: inputSpec [

	| inName outName |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parentNode ifNil: [
		^ #().
	].

	(parentNode isFirstChild: parseNode) ifTrue: [
		^ Array with: (self makeDependencyEdgeFromAttribute: inName at: parentNode toAttribute: outName at: parseNode).
	] ifFalse: [
		^ #().
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forLastChildSynthRule: semanticRule inputSpec: inputSpec [

	| inName outName child |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parseNode isLeaf ifTrue: [
		^ #().
	].

	(child := parseNode getLastChild) ifNotNil: [
		^ Array with: (self makeDependencyEdgeFromAttribute: inName at: child toAttribute: outName at: parseNode).
	] ifNil: [
		^ #().
	].

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forMyInhRule: semanticRule inputSpec: inputSpec [

	| inName outName |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	^ Array with: (self makeDependencyEdgeFromAttribute: inName at: parseNode toAttribute: outName at: parseNode).

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forMySynthRule: semanticRule inputSpec: inputSpec [

	| inName outName |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	^ Array with: (self makeDependencyEdgeFromAttribute: inName at: parseNode toAttribute: outName at: parseNode).

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forParentInhRule: semanticRule inputSpec: inputSpec [

	| inName outName |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parentNode ifNil: ["root"
		^ #().
	].

	^ Array with: (self makeDependencyEdgeFromAttribute: inName at: parentNode toAttribute: outName at: parseNode).

]

{ #category : #private }
KedamaAttributeEvaluator >> makeGraphEdgesAt: parseNode andParent: parentNode forParentSynthRule: semanticRule inputSpec: inputSpec [

	| inName outName |
	inName := inputSpec rawGetter.
	outName := semanticRule output rawGetter.

	parentNode ifNil: ["root"
		^ #().
	].

	^ Array with: (self makeDependencyEdgeFromAttribute: inName at: parentNode toAttribute: outName at: parseNode).

]

{ #category : #private }
KedamaAttributeEvaluator >> matchSpec: spec at: parseNode andParent: parentNode [

	| inName type |
	inName := spec attributeName.
	type := spec type.

	type = #parentInh ifTrue: [
		^ parentNode notNil "(and: [self node: parentNode hasAttribute: inName])"
	].
	type = #parentSynth ifTrue: [
		^ parentNode notNil "(and: [self node: parentNode hasAttribute: inName])"
	].
	type = #allChildrenSynth ifTrue: [
		^ parseNode isLeaf not.
	].
	type = #parentInhFirstChild ifTrue: [
		^ parentNode notNil and: [parentNode isFirstChild: parseNode].
	].
	type = #elderSiblingSynth ifTrue: [
		^ parentNode notNil and: [(parentNode isFirstChild: parseNode) not].
	].
	type = #lastChildSynth ifTrue: [
		^ parseNode isLeaf not and: [parseNode getLastChild notNil].
	].
	type = #myInh ifTrue: [
		^ true.
	].
	type = #mySynth ifTrue: [
		^ true.
	].
	type = #intrinsic ifTrue: [
		^ true.
	].
	^ false.

]

{ #category : #accessing }
KedamaAttributeEvaluator >> parseTree [

	^ parseTree.

]

{ #category : #'input definitions' }
KedamaAttributeEvaluator >> readDefinitionsFrom: aClass [

	Compiler evaluate: aClass generateEvaluatorInput for: self notifying: nil logged: false.

]

{ #category : #private }
KedamaAttributeEvaluator >> selectRuleFor: occurence at: parseNode andParent: parentNode [

	occurence rules do: [:rule |
		(self isApplicable: rule at: parseNode andParent: parentNode) ifTrue: [^ rule].
	].
	^ nil.

]

{ #category : #actions }
KedamaAttributeEvaluator >> sortDependencies [

	| t keys array |
	t := TopologicalSorter new.
	keys := attributedTree allOccurences contents.
	dependencies keys do: [:key |
		array := (dependencies at: key) contents.
		dependencies at: key put: array.
	].
	t collection: keys.
	t edges: dependencies.
	^ t sort.

]
